<h1>Preface</h1>
<h2>The Main Issue</h2>
<p>You love playing games on your Nintendo DS. Every game you've played has been a wonderful experience, each one leaving a lovely aftertaste on your gaming tongue. You may have wondered to yourself what it'd be like to create games, to offer your own software up for licking. You've drawn diagrams of games you'd love to make, worlds you want to share with others. But how to go about it? You think and are lost: you are stuck. Where do I start? Whats going on inside that pretty little dual-screen box?</p>
<p>This manual is designed to help you get an idea of whats going on inside the Nintendo DS. With a bit of effort and time, you'll be on your way to creating your own games. Join us, the homebrew community. You'll have a great time giving others a great time, collaborating on projects, and feeling the rush of intense and under pressure coding for numerous programming competitions.</p>
<h2>The Solution</h2>
<p>This manual is the start of the solution. In it, I will cover the basics of programming the Nintendo DS starting with an explanation of the politics behind the homebrew movement and through the emergence of passthrough devices, how to choose between a Slot-1 device or a Slot-2 device, , how to choose a passthrough device, setting up the programming environment, displaying backgrounds, using sprites, and basic game programming techniques. All these things will be discussed in the context of the creation of a simple game I concocted one weekend entitled "Orange Spaceship."</p>
<h2>How to Use this Manual</h2>
<p>I assume you know a bit of C or C++ coding. If not, spend at least 20 hours making a variety of programs on your own in addition to completing some tutorials. It doesn't matter what you write, so long as you make sure you have a solid understanding of structs, classes, the heap, loops, bitwise and logical operators. I recommend the following tutorial and reference as a great place to get started learning, <a href="http://www.cplusplus.com/doc/tutorial/"></a> and <a href="http://www.cppreference.com/"></a>.</p>
<p>Next, just read through the chapters one by one, making sure you understand the current chapter before moving to the next. Code listings will be on a gray background. Follow along with the code listings, writing your own code based on the listings.</p>
<h1>Politics of the Nintendo DS Homebrew Movement</h1>
<h2>Background Information</h2>
<p>Since the Nintendo DS debut, Nintendo enthusiasts ranging from pre-pubescent kids to 30-year-old college dropouts have been wanting to develop their own games and applications for the Nintendo DS. Nintendo has stated that the DS stands for "Developer's System". For those worthy enough to land a nice developing contract with Nintendo, it truly is. However, most people will never receive this contract, special permission from Nintendo to commercially produce games for the Nintendo DS. In order to obtain a contract with Nintendo, you must prove your worthiness by showcasing an amazing game or other piece of software to them. You must have a stable financial history and expected stable financial future. You must have ample funding to buy all the official Nintendo equipment to develop for the system. Most game development houses don't even get that far. Most games on the market today are put out by what is referred to as a publisher. Game development houses will produce their game partially, show it to a publisher, and the publisher (who already has this development contract with Nintendo) will fund the game development house and market their game. All this bureaucracy makes it very difficult for the common person to produce their own, personal-use games.</p>
<p>This is where the homebrew movement comes in. Dedicated hobbyists spend weeks reverse engineering the Nintendo DS hardware, just to make it possible for common people to produce for the system (by providing a cheap alternative to official Nintendo development). These dedicated hobbyists come from all walks of life and cultures, many from Europe and the U.S., and bring with them great knowledge. These people make up the homebrew movement.</p>
<h2>Is Homebrew Legal?</h2>
<p>Homebrew is legal for a number of reasons. You own the hardware you reverse engineer, so you are free to do with it as you will so long as you don't break the law. Breaking the law would include breaking proprietary copy protection, pirating video games, publishing illegally obtained trade secrets, or otherwise trying to profit off someone else's hard work. Homebrew poses no threat to the official developer kit, as it is so primitive in comparison. Even if you made something to compete with officially produced software, it would be near impossible to publish it. Companies often benefit from homebrew communities. Although software pirates often steal from homebrew discoveries to pirate software, the homebrew community abhors piracy and takes a strong stance against it.</p>
<p>When you buy a piece of hardware, you own it. This means that you are free to break it open, dive into it, reverse engineer it, and so forth. You may void your warranty, but thats the price for learning the intimacies of any system. The only illegal things on this line would be to put into production and sell products made with patented features (without negotiating a production deal with he patent owner), bypassing or breaking copy-protection, or stealing software code. Reverse engineering to learn about how the hardware works and to make something fun for the community is totally fine.</p>
<p>The homebrew tools available for game programming are far behind anything the game company who produced the system could provide (the official development kits). Game system developers have an intimate knowledge of the hardware, as they developed it. The homebrew community has only outsider knowledge through experimentation with the hardware.</p>
<p>It would be close to impossible to publish a game made with homebrew tools. Nintendo would not license your game. It would be hard to find another publisher who would try to publish something made with homebrew tools against Nintendo's will. On other systems besides the Nintendo DS, this is also true.</p>
<p>Companies often don't have a problem with homebrew because it increases the demand for their gaming systems and helps them to learn more about their consumer base. One example of this is with the Xbox. The Xbox homebrew community made the Xbox do things that Microsoft never thought consumers wanted like playindie games, emulate classic game systems, run the Linux operating system, and so forth. Microsoft then included a lot of these features (excepting Linux, of course) in their most recent gaming console, the Xbox 360 via a system called XNA Game Sudio and Xbox LIVE Arcade (XBLA). If a company wants to squash homebrew developers for whatever reason, they'll be smashing an essential fan base that loves that company's hardware design and has the potential to improve it (all at no cost to the company). Homebrew caused such a high demand for the Xbox that it would not have been in Microsoft's best interests to ignore or punish it.</p>
<p>The downside of homebrew is that software pirates often steal from the discoveries of homebrew and use that information to bypass copy-protection and to pirate games. Some companies may take a stance against homebrew for this reason, but doing so is unproductive. Piracy is regrettably inevitable in any industry. It is extremely destructive, annihilating game development houses because publishers will no longer publish their games due to a high piracy rating on the platform the game developers are developing for. Homebrew developers know this, and as the amateur brothers of the official game developers, they share the pain. Homebrew will usually keep all information regarding copy-protection in high secrecy; even if they know how to copy games, they will not share the information. The homebrew community does not want to see the the system they so dearly love come to an early death.</p>
<h1>What is a passthrough device and how do I use one?</h1>
<h2>Purpose of the Passthrough</h2>
<p>The purpose of the pass through is to allow the running of programs on the Nintendo DS through the Game Boy Advance (GBA) cartridge slot. This is done because normal Nintendo DS games, which run from the Nintendo DS (NDS) card slot, are encrypted. Since it might be illegal to break that encryption, as it is a form of proprietary copy protection, we have to get the Nintendo DS to run code from a different place than the NDS card slot. Also, it is much easier to bypass the encryption than to try and break it.</p>
<h2>How a PassMe Works</h2>
<p>When the Nintendo DS first boots, it reads a header from the Nintendo DS card inserted into the NDS card slot. The Nintendo DS will read a small block of information from the beginning of the game, known as the header, which contains information about the game (including the title of the game, date it was released and by who, the icon, and some hardware information). This header contains a pointer to a location in memory to begin executing code. The passthrough's job is to read this header and modify it to point to a location someplace on the GBA cartridge inserted into the GBA cart slot. What location would this be? Why, our code of course.</p>
<h2>History of the Passthrough</h2>
<p>DarkFader (Rafael Vuijk) may have been the first to create a passthrough device. He designed his passthrough with an FPGA (Field Programmable Gate Array) and later packaged it into a single CPLD. Many other people (including Kraln, Firefly, and Natrium42) have developed a passthrough independently from DarkFader, but he is self-credited as its initial creator.</p>
<p>Over the next few months following the creation of the passthrough, Lynx and Natrium42, both major players in the early homebrew community, started their own online stores selling pre-made passthrough devices called "PassMe"s. Many budding DS programmers bought their first passthrough from Lynx or Natrium42's stores (myself included). Lynx's store, DSPassme.com, is still up and running today, providing a great option when looking to purchase a passthrough device.</p>
<figure>
<img src="images/passme.png" alt="Picture of an early PassMe (left) and an FPGA (right)" /><figcaption>Picture of an early PassMe (left) and an FPGA (right)</figcaption>
</figure>
<figure>
<img src="images/ufb-x_profil.jpg" alt="Picture of an early PassMe (left) and an FPGA (right)" /><figcaption>Picture of an early PassMe (left) and an FPGA (right)</figcaption>
</figure>
<h2>The Future is Now, and Now, and Now, and Now</h2>
<p>The PassMe was the first device invented to allow homebrew software to be run on the Nintendo DS. After Nintendo decided to crack down a little harder, in efforts to prevent piracy, these devices no longer worked on new Nintendo DS systems. The community then developed the PassMe 2. This device was more fancy in how it bypassed the copy protection of the Nintendo DS and also required the operator to have more resources (a GBA flash cart with SRAM) and go through a more involved process. After a while, a device called the NoPass surfaced.</p>
<h2>About the NoPass</h2>
<p>A NoPass pretends to be a real Nintendo DS game card. It contains code that is encrypted in the same manner as a real Nintendo DS game. The encryption was broken by Martin Korth, who discovered a way to dump the Nintendo DS BIOS. He then reverse engineered the encryption information from the BIOS code. NoPass devices are technically not considered passthroughs, since they don't bypass the copy protection of the Nintendo DS.</p>
<h2>About Slot-1 Devices</h2>
<p>Recently, due to Martin Korth's work, homebrew engineers have discovered a way to create a device that runs homebrew software from the Nintendo DS card slot (Slot-1). These new devices contain small passthrough devices (of the NoPass style) inside them that allow them to bypass copy protection as well some means of providing memory to the Nintendo DS (via built-in flash memory or a microSD card slot). These devices are called "Slot-1 devices". The older style devices that plug into the GBA cart slot are referred to as "Slot-2 devices".</p>
<h2>How do I get a Passthrough</h2>
<p>Today, many passthrough and NoPass devices are on the market. It is highly recommended by the homebrew community to buy one from a fellow developer and not a company that commercially produces hardware meant for pirating Nintendo DS software. Thus, one should not buy a SuperPass or SuperKey from SuperCard, a MagicKey or MK4-Mini from NeoFlash, a PassKey from G6Flash, a PassKey or Passcard from M3Adapter, or a Max Media Launcher from the horrid Datel (a very unprofessional company run by immature anti-Nintendo kiddies). Each of these companies manufactures hardware that is used to pirate Nintendo DS software and should be avoided at all costs. The best place to buy a passthrough device today is from <a href="http://www.dspassme.com/oscommerce/catalog/index.php">DSPassme.com</a>.</p>
<h2>Which Passthrough Should I Buy?</h2>
<p>It is recommended that you purchase a NoPass or a Slot-1 homebrew device, as these work on all Nintendo DS systems with no troubles or other complications whatsoever. The older passthroughs, like PassMe, don't work on all Nintendo DS systems, and the PassMe 2 requires extra work and resources to use, not to mention they both stick out of your Nintendo DS like a sore thumb and are hard to keep in your pocket.</p>
<p>Slot-1 devices also have many other advantages over Slot-2 devices and passthroughs. You definitely want to get a Slot-1 device. For instance, Slot-2 devices suck up a lot more power than Slot-1 devices do. This means that using a Slot-1 device will give you more battery life than using a Slot-2 device. Many Slot-1 devices also double as NoPass devices, so you don't need to buy both a passthrough and a Slot-2 device anymore.</p>
<h2>How would I choose an old style passthrough?</h2>
<p>If you still want to buy an old fashioned style passthrough, there are a number of things you'll need to consider. Depending on what kind of Nintendo DS you have, you can buy either of two different types of passthrough devices. The first one, akin to the original made by DarkFader, is the "PassMe". The PassMe will probably work on most early "phat" (non-Nintendo DS Lite) Nintendo DS systems.</p>
<p>However, if your Nintendo DS is newer (both phat and Lite systems can be new), you will most likely need a "PassMe 2". The need for a PassMe 2 came about because of a change in the firmware of newer Nintendo DS systems. These newer systems do not allow the header to be changed to point to code in the GBA slot. However, it is possible to point to code in the GBA carts SRAM still. The PassMe 2 points to some certain instructions that have been loaded into memory by the currently inserted DS game. This location is an SWI (software interrupt) call to the SRAM on the GBA port. The GBA carts SRAM contains the necessary code to jump to code lo- cated on GBA cart. The DS then is told to run this code and thus redirects to code in the GBA slot. Each PassMe 2 has to be programmed to work with one specific game, as the certain code to redirect to the GBA slot is found in different places within different DS games.</p>
<p>There are a few tricks you can pull to determine your firmware version. It involves pictochat and pulling a cartridge out of your Nintendo DS. The screen will change a certain color. Based on this color you can determine if you need a PassMe 2 or not. <a href="#game_eject_firmware_table">table_title</a> will help you discover which firmware version you have.</p>
<p>Insert and Nintendo DS game into the DS card slot.</p>
<p>Turn on the Nintendo DS. (If you have auto start enabled, hold down Start and Select when you boot the system.)</p>
<p>Start Pictochat by pressing the Pictochat logo on the menu screen.</p>
<p>Join any room you wish.</p>
<p>Remove the Nintendo DS game inserted into the back of the system.</p>
<p>You will notice either Pictochat freezing or both screens will change color.</p>
<table>
<caption>When ejecting the game, you'll discover your firmware version as shown.</caption>
<thead>
<tr class="header">
<th>Observed Results</th>
<th>Firmware Version</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Pictochat froze</td>
<td>Version 1</td>
</tr>
<tr class="even">
<td>Both screens turned periwinkle</td>
<td>Version 2</td>
</tr>
<tr class="odd">
<td>Both screens turned dark green</td>
<td>Version 3, iQue, or Flashme</td>
</tr>
<tr class="even">
<td>Both screens turned marigold</td>
<td>Version 4</td>
</tr>
<tr class="odd">
<td>Both screens turned magenta</td>
<td>Version 5</td>
</tr>
<tr class="even">
<td>Both screens turned dark blue</td>
<td>Version 6</td>
</tr>
</tbody>
</table>
<p>It is recommended that you purchase a NoPass instead of a PassMe or PassMe 2 passthrough device if you are unsure which to get, as they are guaranteed to work with all Nintendo DS systems, past, present, and future. If you have a friend with a newer DS who may need to borrow your NoPass to play your games, it's always helpful to have a universal method of running them.</p>
<h2>PassMe 2 Buying Tips</h2>
<p>When ordering a PassMe 2, be sure to select one pre-programmed to a common game that you own, such as the Metroid Prime Hunters Demo or Super Mario 64 DS. Each PassMe 2 must be programmed to a specific game and it is best to select a game that is in large supply. Also, you'll need a GBA flash cart with some SRAM on it. Most GBA flash carts have SRAM, but be sure to check your cart before trying to obtain a PassMe 2. Some newer GBA flash carts might only support save games on flash, so simply knowing that your flash cart supports save games isn't enough.</p>
<h2>How do I use my Passthrough</h2>
<p>Using a passthrough device is quite simple. Simply insert a game into the card slot on the passthrough and plug the device into the DS card slot on the top of your DS, like any other game. <a href="#passme_in_use">figure_title</a> illustrates what this looks like.</p>
<figure>
<img src="images/passme_insert_ds.png" alt="The PassMe inserted into the DS card slot" /><figcaption>The PassMe inserted into the DS card slot</figcaption>
</figure>
<h2>What to do with your Passthrough</h2>
<p>One of the best things to do once you get your passthrough is to install a patch to your Nintendo DS firmware known as "FlashMe." This firmware patch allows for the running of unsigned wifi binaries as well as the redirecting of the Nintendo DS to boot from the GBA slot in NDS mode. This means that after installing FlashMe, you no longer need your PassMe. FlashMe is the preferred and recommended method of running your own software. You no longer have to lug around a passthrough or play with a large block sticking out of the back of your DS. Also, you can send your code via wireless multiboot (WMB), if you so desire, and avoid having to use a flash cart. In addition to all those things, in case you ever come across some malicious code that zaps your firmware or otherwise messes up your DS, FlashMe keeps a recovery program in the protected firmware space that you can run to save your DS. Because of this feature alone, FlashMe is better than the standard firmware. FlashMe can be obtained from <a href="http://home.comcast.net/~olimar/flashme/"></a>.</p>
<h1>How do I get programs into my Nintendo DS?</h1>
<h2>The Methods</h2>
<p>There are a few ways of getting your code into the Nintendo DS. The first of which is the simple GBA flash cart. These flash carts are generally quite expensive, have a low availability, and don’t hold very much memory. They fit into the phat Nintendo DS systems perfectly and do not stick out from the bottom, except on the Nintendo DS Lite, as other things do. The second way of running code is on a removable memory device. These kinds of devices come in two flavors: Slot-1 and Slot-2. Slot-2 devices, such as the M3 Adapter, G6 Flash, NeoFlash, SuperCard, and the GBA Movie Player, generally support both Nintendo DS and GBA software. Slot-1 devices, such as the M3 Simply, R4DS, M3 Real, DS-X, NinjaDS, and the Cyclo DS Evolution, generally only support Nintendo DS software. Slot-1 devices also fit into the Nintendo DS perfectly. The first four of those Slot-2 devices are produced by supporters of piracy and should be avoided. It is recommended to use the GBA Movie Player (GBAMP) if you want to use a Slot-2 device. With Slot-1 devices, we don't have too much of a choice but to choose the lesser of many evils.</p>
<h2>Which Slot-1 Device should I buy?</h2>
<p>As there are no homebrew produced devices made by hombrew people for homebrew people (yet), we regretfully have to buy devices designed and sold for piracy when buying NoPass or Slot-1 devices. That said, the most important feature to consider when buying one of these devices is DLDI support.</p>
<h2>What is DLDI?</h2>
<p>DLDI stands for dynamically linked device interface. In order for the homebrew filesystem, known as libfat, to work, you'll need a device which supports the DLDI standard. DLDI specifies a system by which DLDI modules can be dynamically loaded into homebrew software. This allows developers to release one version of their homebrew which the software end users simply patch and then run on a device of their choice. If you buy a device that does not support DLDI, you will be out of luck when wanted to run a majority of the homebrew applications and games out there. Not to mention that the company producing the device is essentially saying, "We don't need to spend time catering to the homebrew community since our device is designed just for piracy." We'd be better off not supporting that kind of company with our business.</p>
<p>You can learn more about DLDI and how to use it at the DLDI Wiki website, <a href="http://dldi.drunkencoders.com/index.php?title=Main_Page"></a>.</p>
<h2>So, which Slot-1 devices are good?</h2>
<p>There are so many Slot-1 devices on the market today. Choosing one of them has become very difficult, as the choices are so many. In this manual, I'll discuss the devices I'm familiar with, which nifty features they propport, and how they compare to one another.</p>
<h2>R4DS</h2>
<p>This device is built well. It is the most sturdy of the three. It uses microSD cards for storage and supports DLDI. This means that you can run homebrew software and use the microSD card's filesystem. With the most recent firmware, it can even automatically patch generic DLDI homebrew software with the proper DLDI driver for the R4DS on the fly. This means that you don't have to use your PC to patch your homebrew software before placing it onto your microSD card. The R4DS cannot use microSDHC cards, however. Some people have complained about the spring loaded microSD slot, so the makers of R4DS have removed it from current models. The R4DS is a great device overall and well supported by the Nintendo DS homebrew community, but it does not support running GBA software unfortunately.</p>
<h2>M3 Real</h2>
<p>This device comes in varying configurations for your various needs. It comes with both a Slot-1 device and a Slot-2 device. The Slot-2 device is what differs between the three M3 Real configurations. In the first and cheapest configuration, the Slot-2 pack is simply a rumble pack. In the second and more expensive version, the Slot-2 pack is a dual rumble and RAM pack. This configuration will also run GBA homebrew. The flash cart size is kept secret by M3, for some reason. Natrium42 was kind enough to inform me that, after doing a few tests on the pack, that it is at least 8MB in size, but lacks SRAM. The third and most expensive configuration, dubbed the "GBA Expansion Package", provides a Slot-2 pack with rumble, SRAM, and 32MB of RAM.</p>
<p>The M3 Real supports DLDI as well. I'm not sure if it can automatially patch homebrew with its own driver on the fly, however. The homebrew software may need to be patched on a PC before being transferred to the SD card.</p>
<p>The M3 Real supports microSD and microSDHC cards, unlike the R4DS. So if you are in the mood for massive storage, the M3 Real can be your friend.</p>
<h2>Cyclo DS Evolution</h2>
<p>This device has very recently come to market, but is already making a big impression in the community. The Cyclo DS Evolution has the best looking and functioning menu system of the three devices, in my opinion. And if you don't like it, the menus are skinnable with a number of skins already available for the device. You might be thinking, "Why would I care what my menus look or act like?" Well, when you use the device to load your software over and over and over again, bad menus really piss you off. When you can't use the touch screen to scroll up and down and select items and have to use the keys, but holding down the keys doesn't make the menu scroll by and you have to press the up and down buttons a lot to get to your software, you get pissed off. And yes, there really are menus that are this bad.</p>
<p>Aside from the pleasant menus, the Cyclo DS Evolution supports DLDI. It also features on the fly DLDI patching. I dislike having to patch my games on my PC before loading them onto my microSD card, so this is a great feature.</p>
<p>My favorite feature of the Cyclo DS Evolution is the "remember what I loaded last time and load that same program again" feature. Simply holding down L and R at boot will boot the last thing that was booted. This enables me to avoid navigating the menu system when I'm debugging a program and running it repeatedly for testing.</p>
<p>The Cyclo DS Evolution also has a NoPass mode where it will act as a NoPass to boot your GBA flash carts, a GBA Movie Player, or any other Slot-2 device.</p>
<p>As you've probably noticed, as I've written the most about the Cyclo DS Evolution, that I like it the best of the three devices. It is competitively priced with the others, which is good. While it doesn't support running GBA software, it feature rich on the Nintendo DS side of things. I recommend the Cyclo DS Evlolution to meet all of your Slot-1 needs and desires.</p>
<h2>Where do I get one of these Slot-1 devices?</h2>
<p>Out of the many places to buy these devices, I've been most happy with electrobee. electrobee is run by a trusted member of the homebrew community and ships worldwide from good ol' Canada (as opposed to who knows where). Their prices are quite often the best, too. When you are ready to purchase a Slot-1 device, I recommend that you visit <a href="http://electrobee.com/index.php?ref=16">electrobee.com</a>.</p>
<h2>The Slot-2 Device of Choice</h2>
<p>If you decide that GBA software development is important for you, you might want to consider getting a NoPass and a Slot-2 device. The NoPass will allow you to run Nintendo DS software from your Slot-2 device. The Slot-2 device, on its own, will be able to run GBA software. If you only care about Nintendo DS software, a Slot-1 device will meet your needs well.</p>
<p>The GBA Movie Player is a wonderful device which can run your software from a Compact Flash card. Compact Flash cards are very cheap and in high supply. If you have more SD cards than CF cards around, unfortunately, the only way to run NDS software from an SD card at this time is with the SD versions of the SuperCard or M3 Adapter. The GBAMP also sticks out from the bottom of the Nintendo DS a little, as shown in <a href="#gbamp_vs_gba_flash_cart">figure_title</a></p>
<figure>
<img src="images/comparison_insertion.png" alt="Comparison of GBAMP (left) and a GBA flash cart (right) inserted into a DS" /><figcaption>Comparison of GBAMP (left) and a GBA flash cart (right) inserted into a DS</figcaption>
</figure>
<p>With the GBA flash cart, the process of loading your programs into memory is a bit slow. Also, each GBA flash cart writer is specific to certain carts and often have closed source drivers. This means that most flash carts will be incompatible with Linux or Macintosh computers. In actuality, the only good thing about a GBA flash cart is that it does not stick out from the Nintendo DS, as can be seen in <a href="#gbamp_vs_gba_flash_cart">figure_title</a>.</p>
<h2>Running Multiple Software Titles</h2>
<p>If you chose to go with the GBA flash cart, you can use a utility called Darkain’s MultiNDS Loader to load multiple programs onto your flash cart. This way, you don’t have to re-flash your cart each time you want to run a different application.</p>
<p>If you chose to go with the GBAMP, then I’d highly recommend DragonMinded's DSOrganize. It supports booting multiple programs, text editing, address books, calendars, and more. It's a great application for the DS. You can get it from <a href="http://www.dragonminded.com/?loc=ndsdev/DSOrganize"></a>. However, you cannot use a stock GBAMP to run NDS programs. You have to flash it with some custom ﬁrmware. Instructions and firmware are available from <a href="http://chishm.drunkencoders.com/NDSMP/index.html"></a>.</p>
<p>As for Slot-1 devices, these all usually come with their own menu systems (often incorrectly referred to as operating systems). You won't have to do anything special to run multiple software titles.</p>
<h1>How do I create programs?</h1>
<h2>All About devkitPro</h2>
<p>devkitPro is a brand, like Microsoft or Adobe. You don't use Nintendo DS software anymore than you write your letters with Microsoft or edit photos with Adobe. devkitPro produces a collection of toolchains for homebrew developers. Toolchains are available for Game Boy Advance, GP32, Playstation Portable, GameCube, and the Nintendo DS. The toolchain we are most interested in is known as devkitARM.</p>
<p>devkitARM is a specific toolchain of devkitPro. It allows the compiling of ARM binaries from most all computers. It is based on gcc, the gnu compiler collection. devkitARM includes everything you'll need to create software for the Nintendo DS, GBA, and GP32; all of which are run by the ARM processor. However, we will be using something to make our job much easier in addition to just devkitARM.</p>
<h2>The Wonderful World of libnds</h2>
<p>libnds, the library for Nintendo DS, started out its life as NDSLIB. NDSLIB was a simple library created by joat (Michael Noland) and dovoto (Jason Rogers). The name was changed to libnds over the course of a few months and the maintainer has been changed to WinterMute (Dave Murphy).</p>
<p>NDSLIB started out as a collection of defines for common memory locations in the DS. This is useful, as you can simply reference BG_BMP_RAM instead of 0x06000000. Eventually, the library began to include structs and unions and other useful constructs that help to simplify the programmers job and abstract certain portions of the hardware from the programmer.</p>
<p>Today, libnds is an incredibly useful library that over 96% of the Nintendo DS homebrew community uses.</p>
<h2>Installing devkitARM</h2>
<p>Installing devkitARM is quite simple. Directions are already documented on their website. Visit <a href="http://www.devkitpro.org/setup.shtml"></a> for directions. Although more geared towards Windows, the installation is fairly straight forward. Automated installers are available for Windows, Macintosh, and Linux.</p>
<h2>Installing libnds from source</h2>
<p>libnds's source install is less documented than devkitPro's source install, but is also quite simple in comparison. libnds is automatically installed by the automated installers of devkitARM. However, if you want to view the libnds source code, you'll have to install it from source.</p>
<p>Simply download the latest source from <a href="http://sourceforge.net/project/showfiles.php%3Fgroup_id%3D114505%26package_id%3D151608">SourceForge.net</a>.</p>
<p>Extract it to <code>$DEVKITPRO/libnds</code>.</p>
<pre><code>            patater@patater.com:~$mkdir
            $DEVKITPRO/libnds
            patater@patater.com:~$mv libnds-src-*.tar
            $DEVKITPRO/libnds/
            patater@patater.com:~$cd
            $DEVKITPRO/libnds
            patater@patater.com:~$tar -xvjf
            libnds-src-*.tar.bz2 $DEVKITPRO/libnds
          </code></pre>
<p>Change your current directory to <code>$DEVKITPRO/libnds</code> and type <code>make</code>.</p>
<pre><code>            patater@patater.com:~$cd
            $DEVKITPRO/libnds
            patater@patater.com:~$make
          </code></pre>
<p>If devkitARM is installed properly, libnds will compile in a matter of seconds and you'll be on your way to developing software for the Nintendo DS.</p>
<h2>The Next Step</h2>
<p>Now that you have devkitARM and libnds installed on your computer, you have everything you need to start coding, excepting perhaps a bit of knowledge on how to code specifically for the unique harware of the Nintendo DS. In the next chapter, we'll cover the basics of displaying a bitmap on the screen.</p>
<p><img src="images/devkitlogo.png" /></p>
<h1>How do I display a background?</h1>
<h2>Some Background Information</h2>
<p>Since the beginning of time, humans have used raster displays to draw electronic images. Raster images aren't used too much anymore, in practice. However, most all displays still act like raster displays from a programming perspective. Each physical display on the Nintendo DS is actually an LCD screen which works nothing like a raster display in actuality, but the electronics that control it provide an interface to the graphics engines on the Nintendo DS that is very much like a raster display.</p>
<p>So what is a raster display? Put simply, it is just like a television display. A beam of electrons blasts away at the back of a phoshor coated screen in a deterministic way (known as a raster scan). The beam, from the perspective of a person watching the television, travels from left to right, one scan line at a time. The beam never blast electrons from right to left. After the beam reaches the right edge of the screen, it turns off and moves to the left edge and down one line. When the beam finally reaches the bottom line of the screen, it travels back up to the upper left of the screen and begins this drawing process all over again. <a href="#raster_display">figure_title</a> illustrates this process in an exaggerated fashion.</p>
<p>Two things are important to remember here. First, that the period of time during which the beam goes from right to left (not drawing anything) is called the horizontal blanking period, or hblank. Second, that the period of time during which the beam goes from bottom to top (again, not drawing anything) is called the vertical blanking period, or vblank. Knowing about vblank is useful for us as Nintendo DS programmers because it is the period of time in which we will tell the Nintendo DS to draw things. If we didn't, then the Nintendo DS display might be in the middle of drawing the screen when we tell it what to draw. This would give us strange artifacts and is generally undesirable.</p>
<figure>
<img src="images/raster_display.svg" alt="The Raster Display" /><figcaption>The Raster Display</figcaption>
</figure>
<h2>The 2D Graphics Engines</h2>
<p>The Nintendo DS has two screens. As such, it has two graphics engines, one for each screen. The first engine is referred to as the "main" engine, while the second is called the "sub" engine. Both of these engines can put in charge of either screen. By default, libnds tells the main engine to operate the top physical screen and the sub screen the bottom physical screen.</p>
<p>Each engine supports up to four backgrounds and up to 128 sprites. They operate independently of each other, each with their own control registers, backgrounds, sprites, graphics data, and palettes. To use an engine, we must first turn them on. Then we place the engine into a certain mode of operation. Next, we map memory for use with the engines. Finally, we load their memory with graphics data and palettes and they automatically just draw what we've set them up to do.</p>
<h2>The Fifth Mode</h2>
<p>Each of these graphics engines can be placed into one of seven different modes that support different features. In this manual, we'll cover one of the more common graphic modes, Mode 5. It is commonly used because it is very flexible and allows for some amazing special effects. We'll learn how to display multiple 15-bit color 1-bit alpha affine backgrounds in this chapter. Mode 5 consists of four different backgrounds each with their own capabilities. <a href="#mode_5_information">table_title</a> shows how flexible Mode 5 can be.</p>
<table>
<caption>Mode 5 Information</caption>
<thead>
<tr class="header">
<th>Background</th>
<th>Purpose</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>Tiled Mode, 2D with 3D support</td>
</tr>
<tr class="even">
<td>1</td>
<td>Tiled Mode, 2D</td>
</tr>
<tr class="odd">
<td>2</td>
<td>Extended Rotation Background</td>
</tr>
<tr class="even">
<td>3</td>
<td>Extended Rotation Background</td>
</tr>
</tbody>
</table>
<h2>A Fine Affine Background</h2>
<p>An affine background, also known as an external rotation background or exrot background, is one that has the ability to be transformed by an affine transformation matrix. Since linear algebra is beyond the scope of this manual, I will cover briefly how to set up a basic affine background, but not get into rotating, scaling, or sheering it. For this manual, we'll just apply an identity transform, a transform that doesn't actually change the background, to our backgrounds. With an affine transformation matrix, you can rotate, scale, and sheer an affine background, among other interesting effects. If you want to learn about the cool effects you can do with an affine background and an affine transformation matrix, I recommend you look at Cearn's tutorial on affine transformations at <a href="http://www.coranac.com/tonc/text/affine.htm"></a>.</p>
<h2>Coding with this Manual</h2>
<p>Since this is the first time in this manual where we'll start to write code, we should be aware of the resources available to assist us in following along with this manual. If you haven't already done so, download the sources that accompany this manual from the manual homepage at <a href="http://patater.com/manual"></a>. After extracting the sources, you'll find a folder called <code>code</code>. The manual provides a template for you to use with this manual and any other Nintendo DS programming projects you might wish to start developing. This template is located in the <code>code</code> folder and is itself a folder called <code>chapter_0-starting_system</code>. The <code>code</code> folder also contains project folders for each chapter. If at anytime you get stuck or if you want to skip a chapter, feel free to refer the completed project for the chapter you are stuck on or to grab the completed project for the chapter prior to the one you wish to skip to. To follow along with this manual, copy the <code>chapter_0-starting_system</code> folder to a nice place you wish to work from (I'd copy the folder to my <code>~/projects</code> directory and name the copy <code>manual</code>) and open <code>source/main.cpp</code> with your favorite text editor. (My favorite text editor is gvim.) Let's get going!</p>
<h2>Initializing the Hardware</h2>
<p>In order to get the hardware to do what we want, we have to first initialize it. This means turning on the 2D graphics core. This is where we first fall in love with libnds. (We'll fall in love with it repeatedly over the course of this manual.) libnds makes it incredibly simple to do these two things. Add the following code to your new <code>main.cpp</code> C++ code file.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode C++"><code class="sourceCode cpp"><a class="sourceLine" id="cb3-1" title="1"><span class="pp">#include </span><span class="im">&lt;nds.h&gt;</span></a>
<a class="sourceLine" id="cb3-2" title="2"></a>
<a class="sourceLine" id="cb3-3" title="3"><span class="dt">int</span> main() {</a>
<a class="sourceLine" id="cb3-4" title="4">  <span class="co">/*  Turn on the 2D graphics core. */</span></a>
<a class="sourceLine" id="cb3-5" title="5">  powerOn(POWER_ALL_2D);</a>
<a class="sourceLine" id="cb3-6" title="6"></a>
<a class="sourceLine" id="cb3-7" title="7">  <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb3-8" title="8">}</a>
<a class="sourceLine" id="cb3-9" title="9">      </a></code></pre></div>
<h2>Configuring the VRAM Banks</h2>
<p>After we get the basic setup done, we now have to tell the graphics engine where to get its display data from. The two graphics engines share the same VRAM; i.e. There are not two VRAM A banks, one for the main screen and one for the sub screen. We'll use these memory locations when we load the graphics later. Let's make a function called <code class="sourceCode cpp">initVideo</code>.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode C++"><code class="sourceCode cpp"><a class="sourceLine" id="cb4-1" title="1"><span class="dt">void</span> initVideo() {</a>
<a class="sourceLine" id="cb4-2" title="2">  <span class="co">/*</span></a>
<a class="sourceLine" id="cb4-3" title="3"><span class="co">   *  Map VRAM to display a background on the main and sub screens.</span></a>
<a class="sourceLine" id="cb4-4" title="4"><span class="co">   *</span></a>
<a class="sourceLine" id="cb4-5" title="5"><span class="co">   *  The vramSetPrimaryBanks function takes four arguments, one for each of</span></a>
<a class="sourceLine" id="cb4-6" title="6"><span class="co">   *  the major VRAM banks. We can use it as shorthand for assigning values to</span></a>
<a class="sourceLine" id="cb4-7" title="7"><span class="co">   *  each of the VRAM bank&#39;s control registers.</span></a>
<a class="sourceLine" id="cb4-8" title="8"><span class="co">   *</span></a>
<a class="sourceLine" id="cb4-9" title="9"><span class="co">   *  We map banks A and B to main screen background memory. This gives us</span></a>
<a class="sourceLine" id="cb4-10" title="10"><span class="co">   *  256KB, which is a healthy amount for 16-bit graphics.</span></a>
<a class="sourceLine" id="cb4-11" title="11"><span class="co">   *</span></a>
<a class="sourceLine" id="cb4-12" title="12"><span class="co">   *  We map bank C to sub screen background memory.</span></a>
<a class="sourceLine" id="cb4-13" title="13"><span class="co">   *</span></a>
<a class="sourceLine" id="cb4-14" title="14"><span class="co">   *  We map bank D to LCD. This setting is generally used for when we aren&#39;t</span></a>
<a class="sourceLine" id="cb4-15" title="15"><span class="co">   *  using a particular bank.</span></a>
<a class="sourceLine" id="cb4-16" title="16"><span class="co">   */</span></a>
<a class="sourceLine" id="cb4-17" title="17">  vramSetPrimaryBanks(VRAM_A_MAIN_BG_0x06000000,</a>
<a class="sourceLine" id="cb4-18" title="18">                      VRAM_B_MAIN_BG_0x06020000,</a>
<a class="sourceLine" id="cb4-19" title="19">                      VRAM_C_SUB_BG_0x06200000,</a>
<a class="sourceLine" id="cb4-20" title="20">                      VRAM_D_LCD);</a>
<a class="sourceLine" id="cb4-21" title="21"></a>
<a class="sourceLine" id="cb4-22" title="22">  <span class="co">/*  Set the video mode on the main screen. */</span></a>
<a class="sourceLine" id="cb4-23" title="23">  videoSetMode(MODE_5_2D | <span class="co">// Set the graphics mode to Mode 5</span></a>
<a class="sourceLine" id="cb4-24" title="24">         DISPLAY_BG2_ACTIVE | <span class="co">// Enable BG2 for display</span></a>
<a class="sourceLine" id="cb4-25" title="25">         DISPLAY_BG3_ACTIVE); <span class="co">//Enable BG3 for display</span></a>
<a class="sourceLine" id="cb4-26" title="26"></a>
<a class="sourceLine" id="cb4-27" title="27">  <span class="co">/*  Set the video mode on the sub screen. */</span></a>
<a class="sourceLine" id="cb4-28" title="28">  videoSetModeSub(MODE_5_2D | <span class="co">// Set the graphics mode to Mode 5</span></a>
<a class="sourceLine" id="cb4-29" title="29">          DISPLAY_BG3_ACTIVE); <span class="co">// Enable BG3 for display</span></a>
<a class="sourceLine" id="cb4-30" title="30">}</a>
<a class="sourceLine" id="cb4-31" title="31">      </a></code></pre></div>
<p>There are nine VRAM banks in total on the Nintendo DS. See <a href="#vram_bank_information">table_title</a> for details about them. Our 16bit background images take up 128KB of memory each. Thus, each background has to have one whole VRAM bank assigned to it. Not all VRAM banks can be used for all purposes, however. Refer to Appendix A, for more detailed information.</p>
<table>
<caption>VRAM Bank Information</caption>
<thead>
<tr class="header">
<th>VRAM Bank</th>
<th>Control Register Address</th>
<th>Control Register</th>
<th>VRAM Bank Size</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>VRAM_A</td>
<td>0x04000240</td>
<td>VRAM_A_CR</td>
<td>128KB</td>
</tr>
<tr class="even">
<td>VRAM_B</td>
<td>0x04000241</td>
<td>VRAM_B_CR</td>
<td>128KB</td>
</tr>
<tr class="odd">
<td>VRAM_C</td>
<td>0x04000242</td>
<td>VRAM_C_CR</td>
<td>128KB</td>
</tr>
<tr class="even">
<td>VRAM_D</td>
<td>0x04000243</td>
<td>VRAM_D_CR</td>
<td>128KB</td>
</tr>
<tr class="odd">
<td>VRAM_E</td>
<td>0x04000244</td>
<td>VRAM_E_CR</td>
<td>64KB</td>
</tr>
<tr class="even">
<td>VRAM_F</td>
<td>0x04000245</td>
<td>VRAM_F_CR</td>
<td>16KB</td>
</tr>
<tr class="odd">
<td>VRAM_G</td>
<td>0x04000246</td>
<td>VRAM_G_CR</td>
<td>16KB</td>
</tr>
<tr class="even">
<td>VRAM_H</td>
<td>0x04000248</td>
<td>VRAM_H_CR</td>
<td>32KB</td>
</tr>
<tr class="odd">
<td>VRAM_I</td>
<td>0x04000249</td>
<td>VRAM_I_CR</td>
<td>16KB</td>
</tr>
</tbody>
</table>
<h2>Setting up the Affine Backgrounds</h2>
<p>libnds helps us once again by provide a nice API for accessing the affine transformation matrix of a particular affine background. libnds provides access to a background's affine transformation matrix through four variables. <a href="#libnds_affine_bg_api">figure_title</a> shows the names of these variables and which part of the affine transformation matrix they align with.</p>
<figure>
<img src="images/libnds_affine_bg_api.svg" alt="libnds Affine Background API" /><figcaption>libnds Affine Background API</figcaption>
</figure>
<p>What we'll do now is add three backgrounds. We'll put a splash screen on the top physical screen, a starfield on the bottom physical screen, and a planet placed atop the starfield background. To do this, we'll use SUB_BG3 (although we could use SUB_BG2) for the splash screen and both backgrounds 2 and 3 on the main screen for the planet and starfield respectively. In order to make sure the planet shows up above the starfield as opposed to below it, we give the planet a priority number less than that of the starfield's priority number. Relatively lower priority numbers place backgrounds relatively above other backgrounds. There are only four priority numbers per graphics engine that we can assign to backgrounds (priority numbers 0-3).</p>
<p>We'll now use that nice API libnds provides us for both the background control registers and the affine transformation matrix. Let's proceed to make a function called <code class="sourceCode cpp">initBackgrounds</code> which will set up our affine backgrounds. Explanations of what is going on is the comments.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode C++"><code class="sourceCode cpp"><a class="sourceLine" id="cb5-1" title="1"><span class="dt">void</span> initBackgrounds() {</a>
<a class="sourceLine" id="cb5-2" title="2">  <span class="co">/*  Set up affine background 3 on main as a 16-bit color background. */</span></a>
<a class="sourceLine" id="cb5-3" title="3">  REG_BG3CNT = BG_BMP16_256x256 |</a>
<a class="sourceLine" id="cb5-4" title="4">         BG_BMP_BASE(<span class="dv">0</span>) | <span class="co">// The starting place in memory</span></a>
<a class="sourceLine" id="cb5-5" title="5">         BG_PRIORITY(<span class="dv">3</span>); <span class="co">// A low priority</span></a>
<a class="sourceLine" id="cb5-6" title="6"></a>
<a class="sourceLine" id="cb5-7" title="7">  <span class="co">/*  Set the affine transformation matrix for the main screen background 3</span></a>
<a class="sourceLine" id="cb5-8" title="8"><span class="co">   *  to be the identity matrix.</span></a>
<a class="sourceLine" id="cb5-9" title="9"><span class="co">   */</span></a>
<a class="sourceLine" id="cb5-10" title="10">  REG_BG3PA = <span class="dv">1</span> &lt;&lt; <span class="dv">8</span>;</a>
<a class="sourceLine" id="cb5-11" title="11">  REG_BG3PB = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb5-12" title="12">  REG_BG3PC = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb5-13" title="13">  REG_BG3PD = <span class="dv">1</span> &lt;&lt; <span class="dv">8</span>;</a>
<a class="sourceLine" id="cb5-14" title="14"></a>
<a class="sourceLine" id="cb5-15" title="15">  <span class="co">/*  Place main screen background 3 at the origin (upper left of the</span></a>
<a class="sourceLine" id="cb5-16" title="16"><span class="co">   *  screen).</span></a>
<a class="sourceLine" id="cb5-17" title="17"><span class="co">   */</span></a>
<a class="sourceLine" id="cb5-18" title="18">  REG_BG3X = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb5-19" title="19">  REG_BG3Y = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb5-20" title="20"></a>
<a class="sourceLine" id="cb5-21" title="21">  <span class="co">/*  Set up affine background 2 on main as a 16-bit color background. */</span></a>
<a class="sourceLine" id="cb5-22" title="22">  REG_BG2CNT = BG_BMP16_128x128 |</a>
<a class="sourceLine" id="cb5-23" title="23">         BG_BMP_BASE(<span class="dv">8</span>) | <span class="co">// The starting place in memory</span></a>
<a class="sourceLine" id="cb5-24" title="24">         BG_PRIORITY(<span class="dv">2</span>);  <span class="co">// A higher priority</span></a>
<a class="sourceLine" id="cb5-25" title="25"></a>
<a class="sourceLine" id="cb5-26" title="26">  <span class="co">/*  Set the affine transformation matrix for the main screen background 3</span></a>
<a class="sourceLine" id="cb5-27" title="27"><span class="co">   *  to be the identity matrix.</span></a>
<a class="sourceLine" id="cb5-28" title="28"><span class="co">   */</span></a>
<a class="sourceLine" id="cb5-29" title="29">  REG_BG2PA = <span class="dv">1</span> &lt;&lt; <span class="dv">8</span>;</a>
<a class="sourceLine" id="cb5-30" title="30">  REG_BG2PB = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb5-31" title="31">  REG_BG2PC = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb5-32" title="32">  REG_BG2PD = <span class="dv">1</span> &lt;&lt; <span class="dv">8</span>;</a>
<a class="sourceLine" id="cb5-33" title="33"></a>
<a class="sourceLine" id="cb5-34" title="34">  <span class="co">/*  Place main screen background 2 in an interesting place. */</span></a>
<a class="sourceLine" id="cb5-35" title="35">  REG_BG2X = -(SCREEN_WIDTH / <span class="dv">2</span> - <span class="dv">32</span>) &lt;&lt; <span class="dv">8</span>;</a>
<a class="sourceLine" id="cb5-36" title="36">  REG_BG2Y = -<span class="dv">32</span> &lt;&lt; <span class="dv">8</span>;</a>
<a class="sourceLine" id="cb5-37" title="37"></a>
<a class="sourceLine" id="cb5-38" title="38">  <span class="co">/*  Set up affine background 3 on the sub screen as a 16-bit color</span></a>
<a class="sourceLine" id="cb5-39" title="39"><span class="co">   *  background.</span></a>
<a class="sourceLine" id="cb5-40" title="40"><span class="co">   */</span></a>
<a class="sourceLine" id="cb5-41" title="41">  REG_BG3CNT_SUB = BG_BMP16_256x256 |</a>
<a class="sourceLine" id="cb5-42" title="42">           BG_BMP_BASE(<span class="dv">0</span>) | <span class="co">// The starting place in memory</span></a>
<a class="sourceLine" id="cb5-43" title="43">           BG_PRIORITY(<span class="dv">3</span>); <span class="co">// A low priority</span></a>
<a class="sourceLine" id="cb5-44" title="44"></a>
<a class="sourceLine" id="cb5-45" title="45">  <span class="co">/*  Set the affine transformation matrix for the sub screen background 3</span></a>
<a class="sourceLine" id="cb5-46" title="46"><span class="co">   *  to be the identity matrix.</span></a>
<a class="sourceLine" id="cb5-47" title="47"><span class="co">   */</span></a>
<a class="sourceLine" id="cb5-48" title="48">  REG_BG3PA_SUB = <span class="dv">1</span> &lt;&lt; <span class="dv">8</span>;</a>
<a class="sourceLine" id="cb5-49" title="49">  REG_BG3PB_SUB = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb5-50" title="50">  REG_BG3PC_SUB = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb5-51" title="51">  REG_BG3PD_SUB = <span class="dv">1</span> &lt;&lt; <span class="dv">8</span>;</a>
<a class="sourceLine" id="cb5-52" title="52"></a>
<a class="sourceLine" id="cb5-53" title="53">  <span class="co">/*</span></a>
<a class="sourceLine" id="cb5-54" title="54"><span class="co">   *  Place main screen background 3 at the origin (upper left of the screen)</span></a>
<a class="sourceLine" id="cb5-55" title="55"><span class="co">   */</span></a>
<a class="sourceLine" id="cb5-56" title="56">  REG_BG3X_SUB = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb5-57" title="57">  REG_BG3Y_SUB = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb5-58" title="58">}</a>
<a class="sourceLine" id="cb5-59" title="59">      </a></code></pre></div>
<h2>Fixed Point Number Primer</h2>
<p>What's up with all those "&lt;&lt; 8" thingies? Those are fixed point numbers. The Nintendo DS expects many values to be in varying fixed point formats. A fixed point number is simply a way of specifying multiples of fractions to represent non-integer values. For example, if we use an integer variable to store a US Dollar amount, we might initially think we can only represent whole dollar values. However, if we decide to store US pennies in the integer as opposed to whole dollar values, we can all of a sudden represent fractions of US Dollars with our integer. We can have 1.21 US Dollars by saying we have 121 pennies.</p>
<p>Common notation for fixed point types looks like 1.31, 1.7.24, 8.8, and etc. To interpret this notation, we read from right to left. First, we find the number of bits used to specify fractional parts. The next number will be the number of bits for whole number parts. And, if there is another number, it will usually indicate the sign of the number as being either positive or negative with one bit. <a href="#fixed_point">figure_title</a> illustrates the concept of fixed point numbers.</p>
<figure>
<img src="images/fixed_point.svg" alt="Integer variables can be used to represent fractions." /><figcaption>Integer variables can be used to represent fractions.</figcaption>
</figure>
<h2>The Basics of DMA</h2>
<p>DMA stands for Direct Memory Access. DMA allows the reading and writing of memory independently of the CPU. The Nintendo DS has special, dedicated DMA hardware to do quick and moderately effcient moving of memory. DMA is not very efficient for memory fill operations, however, as the data to fill with needs to be read once for every write. Libnds provides us with a few functions to make use of the DMA hardware in the Nintendo DS.</p>
<p>Whenever you have the opportunity to use DMA, you should. It is always better to use DMA than to use a for loop to copy data. When using DMA to copy from main memory, do not forget to flush main memory before using DMA. The DMA doesn't use the cache where the relevant memory may currently be stored, so flushing to main memory guarantees that DMA sees the correct data. Another issue to consider would be that in the middle of a DMA, the main CPUs are prevented from using certain memory hardware. This can cause awkward bugs with interrupt handling. For this reason, and <code class="sourceCode cpp">swifastcopy</code> may be safer, and is not too much slower. The safest bet is always <code class="sourceCode cpp">memcopy</code> and <code class="sourceCode cpp">memset</code>, if you are running into some bugs.</p>
<p>The declaration of <code class="sourceCode cpp">dmaCopyHalfWords</code> from libnds is as follows.</p>
static inline void
dmaCopyHalfWords
uint8 channel
const void * source
void * dest
uint32 size
<p>In our program, we will use <code class="sourceCode cpp">dmaCopyHalfWords</code> to load some graphics into memory. We use the function <code class="sourceCode cpp">dmaCopyHalfWords</code> instead of <code class="sourceCode cpp">dmaCopy</code> because it is more explicit as to how it is copying and it lets us specify which DMA channel to use when copying. We'll use the same channel (channel 3) that the ordinary <code class="sourceCode cpp">dmaCopy</code> uses, though. It also let's us specify which DMA channel to use when copying. Let's start out by writing some functions to display our backgrounds. Since we've already set up the hardware to display the data in the desired manner, right after the copy we will get some nice images displayed on our screens. If we didn't set up our backgrounds first, we'd most likely get garbage on the screen until we eventually did set up the background control registers.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode C++"><code class="sourceCode cpp"><a class="sourceLine" id="cb6-1" title="1"><span class="co">/* Select a low priority DMA channel to perform our background</span></a>
<a class="sourceLine" id="cb6-2" title="2"><span class="co"> * copying. */</span></a>
<a class="sourceLine" id="cb6-3" title="3"><span class="at">static</span> <span class="at">const</span> <span class="dt">int</span> DMA_CHANNEL = <span class="dv">3</span>;</a>
<a class="sourceLine" id="cb6-4" title="4"></a>
<a class="sourceLine" id="cb6-5" title="5"><span class="dt">void</span> displayStarField() {</a>
<a class="sourceLine" id="cb6-6" title="6">  dmaCopyHalfWords(DMA_CHANNEL,</a>
<a class="sourceLine" id="cb6-7" title="7">           starFieldBitmap, <span class="co">/* This variable is generated for us by</span></a>
<a class="sourceLine" id="cb6-8" title="8"><span class="co">                     * grit. */</span></a>
<a class="sourceLine" id="cb6-9" title="9">           (uint16 *)BG_BMP_RAM(<span class="dv">0</span>), <span class="co">/* Our address for main</span></a>
<a class="sourceLine" id="cb6-10" title="10"><span class="co">                         * background 3 */</span></a>
<a class="sourceLine" id="cb6-11" title="11">           starFieldBitmapLen); <span class="co">/* This length (in bytes) is generated</span></a>
<a class="sourceLine" id="cb6-12" title="12"><span class="co">                       * from grit. */</span></a>
<a class="sourceLine" id="cb6-13" title="13">}</a>
<a class="sourceLine" id="cb6-14" title="14"></a>
<a class="sourceLine" id="cb6-15" title="15"><span class="dt">void</span> displayPlanet() {</a>
<a class="sourceLine" id="cb6-16" title="16">  dmaCopyHalfWords(DMA_CHANNEL,</a>
<a class="sourceLine" id="cb6-17" title="17">           planetBitmap, <span class="co">/* This variable is generated for us by</span></a>
<a class="sourceLine" id="cb6-18" title="18"><span class="co">                  * grit. */</span></a>
<a class="sourceLine" id="cb6-19" title="19">           (uint16 *)BG_BMP_RAM(<span class="dv">8</span>), <span class="co">/* Our address for main</span></a>
<a class="sourceLine" id="cb6-20" title="20"><span class="co">                         * background 2 */</span></a>
<a class="sourceLine" id="cb6-21" title="21">           planetBitmapLen); <span class="co">/* This length (in bytes) is generated</span></a>
<a class="sourceLine" id="cb6-22" title="22"><span class="co">                    * from grit. */</span></a>
<a class="sourceLine" id="cb6-23" title="23">}</a>
<a class="sourceLine" id="cb6-24" title="24"></a>
<a class="sourceLine" id="cb6-25" title="25"><span class="dt">void</span> displaySplash() {</a>
<a class="sourceLine" id="cb6-26" title="26">  dmaCopyHalfWords(DMA_CHANNEL,</a>
<a class="sourceLine" id="cb6-27" title="27">           splashBitmap, <span class="co">/* This variable is generated for us by</span></a>
<a class="sourceLine" id="cb6-28" title="28"><span class="co">                  * grit. */</span></a>
<a class="sourceLine" id="cb6-29" title="29">           (uint16 *)BG_BMP_RAM_SUB(<span class="dv">0</span>), <span class="co">/* Our address for sub</span></a>
<a class="sourceLine" id="cb6-30" title="30"><span class="co">                           * background 3 */</span></a>
<a class="sourceLine" id="cb6-31" title="31">           splashBitmapLen); <span class="co">/* This length (in bytes) is generated</span></a>
<a class="sourceLine" id="cb6-32" title="32"><span class="co">                    * from grit. */</span></a>
<a class="sourceLine" id="cb6-33" title="33">}</a>
<a class="sourceLine" id="cb6-34" title="34">      </a></code></pre></div>
<h2>Working with the Makefile</h2>
<p>The default template makefile will turn your graphic files into object files for linking into your program. Never include data as a header file.</p>
<p>The graphics must be in a lossless image format, such as gif, tif, bmp, or png in order to work with the provided template makefile. I prefer the png graphic format. Image conversion is usually done by a program called <code>grit</code>. The provided template makefile will ask <code>grit</code> to convert images in the <code>gfx</code> folder of your project root to a format ready for the Nintendo DS.</p>
<p>The provided template makefile, adapted from the default libnds template makefile, is a good base for most all projects. It will look in a folder called <code>gfx</code> (in the same directory as the makefile) for your graphics. If any are found, it uses a special bin2o rule to tell grit to turn your images into .o files, according to grit rule files (with the .grit files extension), which can be linked into your program. <code>grit</code> will create a header file (.h) for your data. The name format for them works like so: if a file is called <code>orangeShuttle.png</code> the header file will be called <code>orangeShuttle.h</code>. Inside this header file will be a reference to the data in the .o, named orangeShuttleTiles and orangeShuttlePal or orangeShuttleBitmap, depending on how the grit file specifies which format to convert your image into. It will also include the length in bytes of the data references as orangeShuttleTilesLen and orangeShuttlePalLen or orangeShuttleBitmapLen.</p>
<p>For our project, we'll be putting the our graphic files and grit rule files into the <code>gfx</code> directory and having the makefile use <code>grit</code> on them.</p>
<h2>Gritty Crash Course</h2>
<p>With the emergence of the awesome and multi-platform tool, <code>grit</code> there is no reason to not learn how to use it. It is now a standard tool in Nintendo DS and GBA development where aforeto there was no universal method of image conversion.</p>
<p>To use grit, we make a grit rule file. This file has the .grit file extension an contains important information telling grit how we want our image converted. You can learn about how grit works by reading its built-in help by running the command <code>grit</code> with no parameters. I've also provided commented grit rule files for all images we will use in this manual. These make good examples and can help you get the hang of using grit.</p>
<p>For more information regarding grit, you can visit the project homepage and read the grit manual at <a href="http://www.coranac.com/projects/grit/"></a> and <a href="http://www.coranac.com/man/grit/html/grit.htm"></a> respectively. You can also download the latest version of grit from the grit project homepage.</p>
<h2>Putting in the Star Fields</h2>
<p>Let's now put these functions into our main() function to get everything working together.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode C++"><code class="sourceCode cpp"><a class="sourceLine" id="cb7-1" title="1"><span class="pp">#include </span><span class="im">&lt;nds.h&gt;</span></a>
<a class="sourceLine" id="cb7-2" title="2"></a>
<a class="sourceLine" id="cb7-3" title="3"><span class="pp">#include </span><span class="im">&quot;starField.h&quot;</span></a>
<a class="sourceLine" id="cb7-4" title="4"><span class="pp">#include </span><span class="im">&quot;planet.h&quot;</span></a>
<a class="sourceLine" id="cb7-5" title="5"><span class="pp">#include </span><span class="im">&quot;splash.h&quot;</span></a>
<a class="sourceLine" id="cb7-6" title="6"></a>
<a class="sourceLine" id="cb7-7" title="7"><span class="co">/* Other functions we&#39;ve made are here. */</span></a>
<a class="sourceLine" id="cb7-8" title="8"></a>
<a class="sourceLine" id="cb7-9" title="9"><span class="dt">int</span> main() {</a>
<a class="sourceLine" id="cb7-10" title="10">  <span class="co">/*  Turn on the 2D graphics core. */</span></a>
<a class="sourceLine" id="cb7-11" title="11">  powerOn(POWER_ALL_2D);</a>
<a class="sourceLine" id="cb7-12" title="12"></a>
<a class="sourceLine" id="cb7-13" title="13">  <span class="co">/*  Configure the VRAM and background control registers. */</span></a>
<a class="sourceLine" id="cb7-14" title="14">  lcdMainOnBottom(); <span class="co">// Place the main screen on the bottom physical screen</span></a>
<a class="sourceLine" id="cb7-15" title="15">  initVideo();</a>
<a class="sourceLine" id="cb7-16" title="16">  initBackgrounds();</a>
<a class="sourceLine" id="cb7-17" title="17"></a>
<a class="sourceLine" id="cb7-18" title="18">  <span class="co">/*  Display the backgrounds. */</span></a>
<a class="sourceLine" id="cb7-19" title="19">  displayStarField();</a>
<a class="sourceLine" id="cb7-20" title="20">  displayPlanet();</a>
<a class="sourceLine" id="cb7-21" title="21">  displaySplash();</a>
<a class="sourceLine" id="cb7-22" title="22"></a>
<a class="sourceLine" id="cb7-23" title="23">  <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb7-24" title="24">}</a>
<a class="sourceLine" id="cb7-25" title="25">      </a></code></pre></div>
<h2>Compiling</h2>
<p>Check over your code, referring to the included examples if needed. Make sure you have the graphics files and the grit rule files in the <code>gfx</code> directory in your project directory. Bring up the command line and set your current working directory to the directory which contains the makefile for your project. Type <code>make</code> and if all goes well, you'll have good success. See <a href="#chapter_5_screen_shot">figure_title</a>. Copy your program to your DS using the method you have chosen.</p>
<figure>
<img src="images/splash.png" alt="The program should look like this when run." /><figcaption>The program should look like this when run.</figcaption>
</figure>
<figure>
<img src="images/starfield_and_planet.png" alt="The program should look like this when run." /><figcaption>The program should look like this when run.</figcaption>
</figure>
<h1>What is a sprite? How do I use them?</h1>
<h2>Magical Fairies?</h2>
<p>No, sprites are not magical fairies. It is a term in 2D graphics programming which refers to an image or animation. The Nintendo DS has dedicated hardware for dealing with sprites. This makes the system very useful for 2D. Most gaming systems do not have a 2D core, and all sprites and other 2D graphics have to be handled manually by painting 2D images on the side of a quad within 3D space.</p>
<h2>The OAM</h2>
<p>The OAM manages all the sprites. This is an immense job, most of it done behind the scenes for us. After using it, you might think it magical. It's not as magical as it seems, however. OAM stands for Object Attribute Memory. It is the place in memory we use to keep track of and control our sprites. The OAM works with a SpriteEntry and a SpriteRotation struct to manage the attributes of our sprites.</p>
<h2>Information About the Sprite Hardware</h2>
<p>On the Nintendo DS, we can have up to 128 sprites. Only 32 of those sprites can be affine transformed (rotated, scaled, skewed, etc.). We are also only allowed to address 1024 different tiles to comprise all of our sprites, per engine. Sprites can be made of tiles that use 16 colors or of ones that use 256 colors. Tiles that use 256 colors are twice as large as tiles that use only 16 colors. Another advantage of using 16-color sprites is the ability to use 16 different palettes. When using 256-color sprites, each sprite (and tile) must use the same palette. When using 16-color sprites, we can have one sprite use one 16-color palette and another sprite use a different 16-color palette, even though both use the same tile data. Games often use this trick to make different colored enemies that look the same. The sprites still use the same tile data, but they use different palettes.</p>
<h2>How Sprites are Stored in Memory</h2>
<p>Sprites are broken into 8x8 pixel pieces. This is called tiling. When drawn to screen, the hardware pieces these tiles together, like a puzzle where the pieces have no distinguishing edges. There are two ways to tile sprites, 1D and 2D. In a 2D layout, the sprite memory is treated like a giant image from which sprite tiles are obtained by making a box the size of the sprite and placing it over the giant image. In a 1D layout, the sprites are layed out in a linear fashion, as discussed in <a href="#sprite_tile_layout">figure_title</a>.</p>
<p>The conversion process is very similar to that for backgrounds. We simple make grit rule files that tell grit how we want our images converted, and it generates a .o and a header file for us. The grit rule files and image files go into the same place as background images, the <code>gfx&gt;</code> folder.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode C++"><code class="sourceCode cpp"><a class="sourceLine" id="cb8-1" title="1"><span class="at">const</span> u16 data[] = {</a>
<a class="sourceLine" id="cb8-2" title="2"><span class="bn">0x0000</span>, <span class="bn">0x0000</span>, <span class="bn">0x0000</span>, <span class="bn">0x0000</span>, <span class="bn">0x0000</span>, <span class="bn">0x0000</span>, <span class="bn">0x0000</span>, <span class="bn">0x0000</span>,</a>
<a class="sourceLine" id="cb8-3" title="3"><span class="bn">0x0F0F</span>, <span class="bn">0x0F0F</span>, <span class="bn">0x0F0F</span>, <span class="bn">0x0F0F</span>, <span class="bn">0x0F0F</span>, <span class="bn">0x0F0F</span>, <span class="bn">0x0F0F</span>, <span class="bn">0x0F0F</span>,</a>
<a class="sourceLine" id="cb8-4" title="4"><span class="bn">0x2020</span>, <span class="bn">0x2020</span>, <span class="bn">0x2020</span>, <span class="bn">0x2020</span>, <span class="bn">0x2020</span>, <span class="bn">0x2020</span>, <span class="bn">0x2020</span>, <span class="bn">0x2020</span>,</a>
<a class="sourceLine" id="cb8-5" title="5"><span class="bn">0x2F2F</span>, <span class="bn">0x2F2F</span>, <span class="bn">0x2F2F</span>, <span class="bn">0x2F2F</span>, <span class="bn">0x2F2F</span>, <span class="bn">0x2F2F</span>, <span class="bn">0x2F2F</span>, <span class="bn">0x2F2F</span>,</a>
<a class="sourceLine" id="cb8-6" title="6"><span class="bn">0x4040</span>, <span class="bn">0x4040</span>, <span class="bn">0x4040</span>, <span class="bn">0x4040</span>, <span class="bn">0x4040</span>, <span class="bn">0x4040</span>, <span class="bn">0x4040</span>, <span class="bn">0x4040</span>,</a>
<a class="sourceLine" id="cb8-7" title="7"><span class="bn">0x4F4F</span>, <span class="bn">0x4F4F</span>, <span class="bn">0x4F4F</span>, <span class="bn">0x4F4F</span>, <span class="bn">0x4F4F</span>, <span class="bn">0x4F4F</span>, <span class="bn">0x4F4F</span>, <span class="bn">0x4F4F</span>,</a>
<a class="sourceLine" id="cb8-8" title="8"><span class="bn">0x6060</span>, <span class="bn">0x6060</span>, <span class="bn">0x6060</span>, <span class="bn">0x6060</span>, <span class="bn">0x6060</span>, <span class="bn">0x6060</span>, <span class="bn">0x6060</span>, <span class="bn">0x6060</span>,</a>
<a class="sourceLine" id="cb8-9" title="9"><span class="bn">0x6F6F</span>, <span class="bn">0x6F6F</span>, <span class="bn">0x6F6F</span>, <span class="bn">0x6F6F</span>, <span class="bn">0x6F6F</span>, <span class="bn">0x6F6F</span>, <span class="bn">0x6F6F</span>, <span class="bn">0x6F6F</span>,</a>
<a class="sourceLine" id="cb8-10" title="10"><span class="bn">0x8080</span>, <span class="bn">0x8080</span>, <span class="bn">0x8080</span>, <span class="bn">0x8080</span>, <span class="bn">0x8080</span>, <span class="bn">0x8080</span>, <span class="bn">0x8080</span>, <span class="bn">0x8080</span>,</a>
<a class="sourceLine" id="cb8-11" title="11"><span class="bn">0x8F8F</span>, <span class="bn">0x8F8F</span>, <span class="bn">0x8F8F</span>, <span class="bn">0x8F8F</span>, <span class="bn">0x8F8F</span>, <span class="bn">0x8F8F</span>, <span class="bn">0x8F8F</span>, <span class="bn">0x8F8F</span>,</a>
<a class="sourceLine" id="cb8-12" title="12"><span class="bn">0xA0A0</span>, <span class="bn">0xA0A0</span>, <span class="bn">0xA0A0</span>, <span class="bn">0xA0A0</span>, <span class="bn">0xA0A0</span>, <span class="bn">0xA0A0</span>, <span class="bn">0xA0A0</span>, <span class="bn">0xA0A0</span>,</a>
<a class="sourceLine" id="cb8-13" title="13"><span class="bn">0xAFAF</span>, <span class="bn">0xAFAF</span>, <span class="bn">0xAFAF</span>, <span class="bn">0xAFAF</span>, <span class="bn">0xAFAF</span>, <span class="bn">0xAFAF</span>, <span class="bn">0xAFAF</span>, <span class="bn">0xAFAF</span>,</a>
<a class="sourceLine" id="cb8-14" title="14"><span class="bn">0xC0C0</span>, <span class="bn">0xC0C0</span>, <span class="bn">0xC0C0</span>, <span class="bn">0xC0C0</span>, <span class="bn">0xC0C0</span>, <span class="bn">0xC0C0</span>, <span class="bn">0xC0C0</span>, <span class="bn">0xC0C0</span>,</a>
<a class="sourceLine" id="cb8-15" title="15"><span class="bn">0xCFCF</span>, <span class="bn">0xCFCF</span>, <span class="bn">0xCFCF</span>, <span class="bn">0xCFCF</span>, <span class="bn">0xCFCF</span>, <span class="bn">0xCFCF</span>, <span class="bn">0xCFCF</span>, <span class="bn">0xCFCF</span>,</a>
<a class="sourceLine" id="cb8-16" title="16"><span class="bn">0xE0E0</span>, <span class="bn">0xE0E0</span>, <span class="bn">0xE0E0</span>, <span class="bn">0xE0E0</span>, <span class="bn">0xE0E0</span>, <span class="bn">0xE0E0</span>, <span class="bn">0xE0E0</span>, <span class="bn">0xE0E0</span>,</a>
<a class="sourceLine" id="cb8-17" title="17"><span class="bn">0xEFEF</span>, <span class="bn">0xEFEF</span>, <span class="bn">0xEFEF</span>, <span class="bn">0xEFEF</span>, <span class="bn">0xEFEF</span>, <span class="bn">0xEFEF</span>, <span class="bn">0xEFEF</span>, <span class="bn">0xEFEF</span>};</a>
<a class="sourceLine" id="cb8-18" title="18"><span class="at">const</span> u16 data[] = {</a>
<a class="sourceLine" id="cb8-19" title="19"><span class="bn">0x0000</span>, <span class="bn">0x0000</span>, <span class="bn">0x0000</span>, <span class="bn">0x0000</span>, <span class="bn">0x0F0F</span>, <span class="bn">0x0F0F</span>, <span class="bn">0x0F0F</span>, <span class="bn">0x0F0F</span>,</a>
<a class="sourceLine" id="cb8-20" title="20"><span class="bn">0x2020</span>, <span class="bn">0x2020</span>, <span class="bn">0x2020</span>, <span class="bn">0x2020</span>, <span class="bn">0x2F2F</span>, <span class="bn">0x2F2F</span>, <span class="bn">0x2F2F</span>, <span class="bn">0x2F2F</span>,</a>
<a class="sourceLine" id="cb8-21" title="21"><span class="bn">0x4040</span>, <span class="bn">0x4040</span>, <span class="bn">0x4040</span>, <span class="bn">0x4040</span>, <span class="bn">0x4F4F</span>, <span class="bn">0x4F4F</span>, <span class="bn">0x4F4F</span>, <span class="bn">0x4F4F</span>,</a>
<a class="sourceLine" id="cb8-22" title="22"><span class="bn">0x6060</span>, <span class="bn">0x6060</span>, <span class="bn">0x6060</span>, <span class="bn">0x6060</span>, <span class="bn">0x6F6F</span>, <span class="bn">0x6F6F</span>, <span class="bn">0x6F6F</span>, <span class="bn">0x6F6F</span>,</a>
<a class="sourceLine" id="cb8-23" title="23"><span class="bn">0x0000</span>, <span class="bn">0x0000</span>, <span class="bn">0x0000</span>, <span class="bn">0x0000</span>, <span class="bn">0x0F0F</span>, <span class="bn">0x0F0F</span>, <span class="bn">0x0F0F</span>, <span class="bn">0x0F0F</span>,</a>
<a class="sourceLine" id="cb8-24" title="24"><span class="bn">0x2020</span>, <span class="bn">0x2020</span>, <span class="bn">0x2020</span>, <span class="bn">0x2020</span>, <span class="bn">0x2F2F</span>, <span class="bn">0x2F2F</span>, <span class="bn">0x2F2F</span>, <span class="bn">0x2F2F</span>,</a>
<a class="sourceLine" id="cb8-25" title="25"><span class="bn">0x4040</span>, <span class="bn">0x4040</span>, <span class="bn">0x4040</span>, <span class="bn">0x4040</span>, <span class="bn">0x4F4F</span>, <span class="bn">0x4F4F</span>, <span class="bn">0x4F4F</span>, <span class="bn">0x4F4F</span>,</a>
<a class="sourceLine" id="cb8-26" title="26"><span class="bn">0x6060</span>, <span class="bn">0x6060</span>, <span class="bn">0x6060</span>, <span class="bn">0x6060</span>, <span class="bn">0x6F6F</span>, <span class="bn">0x6F6F</span>, <span class="bn">0x6F6F</span>, <span class="bn">0x6F6F</span>,</a>
<a class="sourceLine" id="cb8-27" title="27"><span class="bn">0x8080</span>, <span class="bn">0x8080</span>, <span class="bn">0x8080</span>, <span class="bn">0x8080</span>, <span class="bn">0x8F8F</span>, <span class="bn">0x8F8F</span>, <span class="bn">0x8F8F</span>, <span class="bn">0x8F8F</span>,</a>
<a class="sourceLine" id="cb8-28" title="28"><span class="bn">0xA0A0</span>, <span class="bn">0xA0A0</span>, <span class="bn">0xA0A0</span>, <span class="bn">0xA0A0</span>, <span class="bn">0xAFAF</span>, <span class="bn">0xAFAF</span>, <span class="bn">0xAFAF</span>, <span class="bn">0xAFAF</span>,</a>
<a class="sourceLine" id="cb8-29" title="29"><span class="bn">0xC0C0</span>, <span class="bn">0xC0C0</span>, <span class="bn">0xC0C0</span>, <span class="bn">0xC0C0</span>, <span class="bn">0xCFCF</span>, <span class="bn">0xCFCF</span>, <span class="bn">0xCFCF</span>, <span class="bn">0xCFCF</span>,</a>
<a class="sourceLine" id="cb8-30" title="30"><span class="bn">0xE0E0</span>, <span class="bn">0xE0E0</span>, <span class="bn">0xE0E0</span>, <span class="bn">0xE0E0</span>, <span class="bn">0xEFEF</span>, <span class="bn">0xEFEF</span>, <span class="bn">0xEFEF</span>, <span class="bn">0xEFEF</span>,</a>
<a class="sourceLine" id="cb8-31" title="31"><span class="bn">0x8080</span>, <span class="bn">0x8080</span>, <span class="bn">0x8080</span>, <span class="bn">0x8080</span>, <span class="bn">0x8F8F</span>, <span class="bn">0x8F8F</span>, <span class="bn">0x8F8F</span>, <span class="bn">0x8F8F</span>,</a>
<a class="sourceLine" id="cb8-32" title="32"><span class="bn">0xA0A0</span>, <span class="bn">0xA0A0</span>, <span class="bn">0xA0A0</span>, <span class="bn">0xA0A0</span>, <span class="bn">0xAFAF</span>, <span class="bn">0xAFAF</span>, <span class="bn">0xAFAF</span>, <span class="bn">0xAFAF</span>,</a>
<a class="sourceLine" id="cb8-33" title="33"><span class="bn">0xC0C0</span>, <span class="bn">0xC0C0</span>, <span class="bn">0xC0C0</span>, <span class="bn">0xC0C0</span>, <span class="bn">0xCFCF</span>, <span class="bn">0xCFCF</span>, <span class="bn">0xCFCF</span>, <span class="bn">0xCFCF</span>,</a>
<a class="sourceLine" id="cb8-34" title="34"><span class="bn">0xE0E0</span>, <span class="bn">0xE0E0</span>, <span class="bn">0xE0E0</span>, <span class="bn">0xE0E0</span>, <span class="bn">0xEFEF</span>, <span class="bn">0xEFEF</span>, <span class="bn">0xEFEF</span>, <span class="bn">0xEFEF</span>};</a>
<a class="sourceLine" id="cb8-35" title="35">        </a></code></pre></div>
<h2>Sprite Attributes</h2>
<p>Sprites have three attribute variables associated with them. With them, sprites can spin and flip and mosaic and perform all sorts of fun hardware effects. Each attribute is multi-purpose and requires some amount of bit twiddling and masking to achieve the affects we want. That is, it would if it weren't for this nice SpriteEntry union which libnds provides for us. In most cases, we will use this union to do what we'd like to with our sprites, but there are special cases where this is not possible.</p>
<p>We will cover how to update, initialize, and rotate using bit twiddling methods, as libnds doesn't yet provide ways of doing this otherwise. libnds provides the means to do other things that we'll be doing with sprites though, like move them, we'll be doing. We'll use the libnds API wherever possible. Let's write some functions to do each of those, in that order.</p>
<p>I provide you with a header file, located with the acompanying source at <code>code/chapter_6-sprites/include/sprites.h</code> that contains a collection of sprite related function declarations. We'll be working on the definitions for each of these functions together in a new file called <code>sprites.cpp</code>. Our first step will be to create a that new source code file. Put a new file called <code>sprites.cpp</code> into the <code>source</code> folder of your project directory.</p>
<h2>Updating the OAM</h2>
<p>Instead of keeping track of things directly in the OAM, we'll manage a copy of the OAM in memory that we will copy over every frame using <code class="sourceCode cpp">updateOAM</code>. The reason we do this is because writes to OAM are locked during all times but during vblank. We will wait for vblank to occur before copying our copy of the OAM into the actualy OAM.</p>
<p>Updating the OAM is very straightforward. We do this by copying our copy of the OAM to the real OAM. Our copy of the OAM might still be stuck in the cache and may not have made it into main memory yet, so we first flush local memory (a must whenever performing a DMA operation) to ensure that DMA sees the correct data. The data we want to copy might be stuck in cache still and may not have made it into main memory yet. Then, we tell the OAM to look into the OAMTable instance we will create later for information about each one of our sprites.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode C++"><code class="sourceCode cpp"><a class="sourceLine" id="cb9-1" title="1"><span class="dt">void</span> updateOAM(OAMTable * oam) {</a>
<a class="sourceLine" id="cb9-2" title="2">  DC_FlushAll();</a>
<a class="sourceLine" id="cb9-3" title="3">  dmaCopyHalfWords(SPRITE_DMA_CHANNEL,</a>
<a class="sourceLine" id="cb9-4" title="4">           oam-&gt;oamBuffer,</a>
<a class="sourceLine" id="cb9-5" title="5">           OAM,</a>
<a class="sourceLine" id="cb9-6" title="6">           SPRITE_COUNT * <span class="kw">sizeof</span>(SpriteEntry));</a>
<a class="sourceLine" id="cb9-7" title="7">}</a>
<a class="sourceLine" id="cb9-8" title="8">      </a></code></pre></div>
<h2>Initializing the OAM</h2>
<p>The first thing we do when initializing the OAM is to clear all the sprite data in the OAM. After that, we'll make a call to our afore written <code class="sourceCode cpp">updateOAM</code> function.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode C++"><code class="sourceCode cpp"><a class="sourceLine" id="cb10-1" title="1"><span class="dt">void</span> iniOAMTable(OAMTable * oam) {</a>
<a class="sourceLine" id="cb10-2" title="2">  <span class="co">/*</span></a>
<a class="sourceLine" id="cb10-3" title="3"><span class="co">   * For all 128 sprites on the DS, disable and clear any attributes they</span></a>
<a class="sourceLine" id="cb10-4" title="4"><span class="co">   * might have. This prevents any garbage from being displayed and gives</span></a>
<a class="sourceLine" id="cb10-5" title="5"><span class="co">   * us a clean slate to work with.</span></a>
<a class="sourceLine" id="cb10-6" title="6"><span class="co">   */</span></a>
<a class="sourceLine" id="cb10-7" title="7">  <span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; SPRITE_COUNT; i++) {</a>
<a class="sourceLine" id="cb10-8" title="8">    oam-&gt;oamBuffer[i].attribute[<span class="dv">0</span>] = ATTR0_DISABLED;</a>
<a class="sourceLine" id="cb10-9" title="9">    oam-&gt;oamBuffer[i].attribute[<span class="dv">1</span>] = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb10-10" title="10">    oam-&gt;oamBuffer[i].attribute[<span class="dv">2</span>] = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb10-11" title="11">  }</a>
<a class="sourceLine" id="cb10-12" title="12">  <span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; MATRIX_COUNT; i++) {</a>
<a class="sourceLine" id="cb10-13" title="13">    <span class="co">/* If you look carefully, you&#39;ll see this is that affine trasformation</span></a>
<a class="sourceLine" id="cb10-14" title="14"><span class="co">     * matrix again. We initialize it to the identity matrix, as we did</span></a>
<a class="sourceLine" id="cb10-15" title="15"><span class="co">     * with backgrounds</span></a>
<a class="sourceLine" id="cb10-16" title="16"><span class="co">     */</span></a>
<a class="sourceLine" id="cb10-17" title="17">    oam-&gt;matrixBuffer[i].hdx = <span class="dv">1</span> &lt;&lt; <span class="dv">8</span>;</a>
<a class="sourceLine" id="cb10-18" title="18">    oam-&gt;matrixBuffer[i].hdy = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb10-19" title="19">    oam-&gt;matrixBuffer[i].vdx = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb10-20" title="20">    oam-&gt;matrixBuffer[i].vdy = <span class="dv">1</span> &lt;&lt; <span class="dv">8</span>;</a>
<a class="sourceLine" id="cb10-21" title="21">  }</a>
<a class="sourceLine" id="cb10-22" title="22">  updateOAM(oam);</a>
<a class="sourceLine" id="cb10-23" title="23">}</a>
<a class="sourceLine" id="cb10-24" title="24">      </a></code></pre></div>
<h2>Rotating Sprites</h2>
<p>Let's get to spinning. This is a bit more difficult than what we've done before, but still fun. It's nice to not have to make a separate sprite for each rotation position the sprite will be presented in. However, doing so may be necessary for some applications as the Nintendo DS rotation won't always look as pretty as if the rotations had been done elsewhere.</p>
<p>The libnds's sin and cos lookup tables employ a 32768 degree system. Humans usually use a 360 degree system or radians. The angle we'll work with in this function will be one that is part of the 32768 degree system. You'll have to convert your radians or weird 360 degree value (Seriously, why 360? Silly Babylonians.) to the 32768 degree system before using this function in order to see the results you are expecting.</p>
<p>We have to use a transformation derived from our time spent playing with an affine transformation matrix. The sprite's affine transformation matrix is used slightly differently from the background affine transformation matrix. If you have a background in linear algebra, I'd recommend reading up on this portion of the hardware at <a href="http://www.coranac.com/tonc/text/affine.htm"></a>.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode C++"><code class="sourceCode cpp"><a class="sourceLine" id="cb11-1" title="1"><span class="dt">void</span> rotateSprite(SpriteRotation * spriteRotation, <span class="dt">int</span> angle) {</a>
<a class="sourceLine" id="cb11-2" title="2">  s16 s = sinLerp(angle) &gt;&gt; <span class="dv">4</span>;</a>
<a class="sourceLine" id="cb11-3" title="3">  s16 c = cosLerp(angle) &gt;&gt; <span class="dv">4</span>;</a>
<a class="sourceLine" id="cb11-4" title="4"></a>
<a class="sourceLine" id="cb11-5" title="5">  spriteRotation-&gt;hdx = c;</a>
<a class="sourceLine" id="cb11-6" title="6">  spriteRotation-&gt;hdy = s;</a>
<a class="sourceLine" id="cb11-7" title="7">  spriteRotation-&gt;vdx = -s;</a>
<a class="sourceLine" id="cb11-8" title="8">  spriteRotation-&gt;vdy = c;</a>
<a class="sourceLine" id="cb11-9" title="9">}</a>
<a class="sourceLine" id="cb11-10" title="10">      </a></code></pre></div>
<h2>Showing and Hiding Sprites</h2>
<p>Up until now, we haven't used the fancy SpriteEntry union included in libnds. It allows us to avoid thinking about bit twiddling and masking in most cases. In the case of showing and hiding sprites, we still need to be thinking about these bits due to an oddity in the Nintendo DS hardware: the hiding bit of a sprite (bit 9 of sprite attribute 0) is also the double bound bit of a sprite if the sprite is an affine sprite (bit 8 of sprite attribute 0). Follow along with the comments and code as we formulate a solution to writing a function which shows and hides all kinds of sprites.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode C++"><code class="sourceCode cpp"><a class="sourceLine" id="cb12-1" title="1"><span class="dt">void</span> setSpriteVisibility(SpriteEntry * spriteEntry, <span class="dt">bool</span> hidden, <span class="dt">bool</span> affine,</a>
<a class="sourceLine" id="cb12-2" title="2">             <span class="dt">bool</span> doubleBound) {</a>
<a class="sourceLine" id="cb12-3" title="3">  <span class="cf">if</span> (hidden) {</a>
<a class="sourceLine" id="cb12-4" title="4">    <span class="co">/*</span></a>
<a class="sourceLine" id="cb12-5" title="5"><span class="co">     * Make the sprite invisible.</span></a>
<a class="sourceLine" id="cb12-6" title="6"><span class="co">     *</span></a>
<a class="sourceLine" id="cb12-7" title="7"><span class="co">     * An affine sprite cannot be hidden. We have to turn it into a</span></a>
<a class="sourceLine" id="cb12-8" title="8"><span class="co">     * non-affine sprite before we can hide it. To hide any sprite, we must</span></a>
<a class="sourceLine" id="cb12-9" title="9"><span class="co">     * set bit 8 and clear bit 9. For non-affine sprites, this is a bit</span></a>
<a class="sourceLine" id="cb12-10" title="10"><span class="co">     * redundant, but it is faster than a branch to just set it regardless</span></a>
<a class="sourceLine" id="cb12-11" title="11"><span class="co">     * of whether or not it is already set.</span></a>
<a class="sourceLine" id="cb12-12" title="12"><span class="co">     */</span></a>
<a class="sourceLine" id="cb12-13" title="13">    spriteEntry-&gt;isRotateScale = <span class="kw">false</span>; <span class="co">// Bit 9 off</span></a>
<a class="sourceLine" id="cb12-14" title="14">    spriteEntry-&gt;isHidden = <span class="kw">true</span>; <span class="co">// Bit 8 on</span></a>
<a class="sourceLine" id="cb12-15" title="15">  } <span class="cf">else</span> {</a>
<a class="sourceLine" id="cb12-16" title="16">    <span class="co">/* Make the sprite visible.*/</span></a>
<a class="sourceLine" id="cb12-17" title="17">    <span class="cf">if</span> (affine) {</a>
<a class="sourceLine" id="cb12-18" title="18">      <span class="co">/* Again, keep in mind that affine sprites cannot be hidden, so</span></a>
<a class="sourceLine" id="cb12-19" title="19"><span class="co">       * enabling affine is enough to show the sprite again. We also need</span></a>
<a class="sourceLine" id="cb12-20" title="20"><span class="co">       * to allow the user to get the double bound flag in the sprite</span></a>
<a class="sourceLine" id="cb12-21" title="21"><span class="co">       * attribute. If we did not, then our sprite hiding function would</span></a>
<a class="sourceLine" id="cb12-22" title="22"><span class="co">       * not be able to properly hide and restore double bound sprites.</span></a>
<a class="sourceLine" id="cb12-23" title="23"><span class="co">       * We enable bit 9 here because we want an affine sprite.</span></a>
<a class="sourceLine" id="cb12-24" title="24"><span class="co">       */</span></a>
<a class="sourceLine" id="cb12-25" title="25">      spriteEntry-&gt;isRotateScale = <span class="kw">true</span>;</a>
<a class="sourceLine" id="cb12-26" title="26"></a>
<a class="sourceLine" id="cb12-27" title="27">      <span class="co">/* The double bound flag only acts as the double bound flag when</span></a>
<a class="sourceLine" id="cb12-28" title="28"><span class="co">       * the sprite is an affine sprite. At all other times, it acts as</span></a>
<a class="sourceLine" id="cb12-29" title="29"><span class="co">       * the sprite invisibility flag. We only enable bit 8 here if we want</span></a>
<a class="sourceLine" id="cb12-30" title="30"><span class="co">       * a double bound sprite. */</span></a>
<a class="sourceLine" id="cb12-31" title="31">      spriteEntry-&gt;isSizeDouble = doubleBound;</a>
<a class="sourceLine" id="cb12-32" title="32">    } <span class="cf">else</span> {</a>
<a class="sourceLine" id="cb12-33" title="33">      <span class="co">/* Bit 9 (the affine flag) will already be off here, so we don&#39;t</span></a>
<a class="sourceLine" id="cb12-34" title="34"><span class="co">       * need to clear it. However, bit 8 (the sprite invisibility flag)</span></a>
<a class="sourceLine" id="cb12-35" title="35"><span class="co">       * will need to be cleared. */</span></a>
<a class="sourceLine" id="cb12-36" title="36">      spriteEntry-&gt;isHidden = <span class="kw">false</span>;</a>
<a class="sourceLine" id="cb12-37" title="37">    }</a>
<a class="sourceLine" id="cb12-38" title="38">  }</a>
<a class="sourceLine" id="cb12-39" title="39">}</a>
<a class="sourceLine" id="cb12-40" title="40">      </a></code></pre></div>
<h2>Moving Sprites</h2>
<p>Now for some real fun. Moving sprites in hardware, and not having to worry about clipping, buffers, or anything, is such a wonderful feeling. To move a sprite, we simply change the SpriteEntry properties x and y. This is a case where we don't have to think much about the underlying arrangement of this information. The libnds union SpriteEntry describes the organization of data to the compiler for us and the compiler then figures out the best way to operate on that data; the compiler does the bit twiddling and masking for us. Since this is so simple, we don't even need to write a function to do it for us. So just take note of what we do here and remember it for later; you don't have to write a function for it, but if you want to I'd recommend making it an inline function.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode C++"><code class="sourceCode cpp"><a class="sourceLine" id="cb13-1" title="1"><span class="co">/* This is what we&#39;d do if we wanted to move a sprite. */</span></a>
<a class="sourceLine" id="cb13-2" title="2">spriteEntry-&gt;x = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb13-3" title="3">spriteEntry-&gt;y = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb13-4" title="4">      </a></code></pre></div>
<h2>Setting Sprite Priorities</h2>
<p>The ability to set a sprites priorty is essential when dealing with multiple sprites, as we will be doing. As such, we'll now discuss sprite priorities and how to set them.</p>
<p>A sprite, like a background, has a priorty which determines how the sprite will appear with respect to other sprites and to backgrounds. A sprite with the same number priorty as a background will appear above it. A sprite with a lower priorty number than another sprite will appear above that other sprite. There are four priorities per graphics engine available for sprites, similar to background priorities.</p>
<p>To set the sprite priority, we'll simply set the SpriteEntry property priority to one of four different values, depending on which priority we wish to assign: OBJPRIORITY_0, OBJPRIORITY_1, OBJPRIORITY_2, or OBJPRIORITY_3. The following code listing shows an example of what this looks like.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode C++"><code class="sourceCode cpp"><a class="sourceLine" id="cb14-1" title="1">spriteEntry-&gt;priority = OBJPRIORITY_3;</a>
<a class="sourceLine" id="cb14-2" title="2">      </a></code></pre></div>
<h2>Using the Sprites</h2>
<p>Now that our sprites.cpp file is finished, let's get on to how sprites are stored in memory, how to load them, and so forth. So put away your sprites.cpp file into the source directory of your home folder and let's get back into our <code>main.cpp</code> file.</p>
<h2>Setting up VRAM for Sprites</h2>
<p>We'll need to make a place for our sprite data to live in VRAM. Since we will be using sprites on the main graphics engine, we can use VRAM bank E for our sprites. VRAM bank E is smaller than the other VRAM banks we've dealt with so far, as it is only 64 KB in size. However, this is more than enough to store 1024 unique 16-color tiles.</p>
<p>In our <code class="sourceCode cpp">initVideo</code>, we need to map VRAM bank E for use with sprites on the main graphics engine. Then, we need to tell the main engine to enable sprites of the tiling style we want. We will use 1D tiled sprites. The resulting initVideo function, post-modifications, is presented below .</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode C++"><code class="sourceCode cpp"><a class="sourceLine" id="cb15-1" title="1"><span class="dt">void</span> initVideo() {</a>
<a class="sourceLine" id="cb15-2" title="2">  <span class="co">/*</span></a>
<a class="sourceLine" id="cb15-3" title="3"><span class="co">   *  Map VRAM to display a background on the main and sub screens.</span></a>
<a class="sourceLine" id="cb15-4" title="4"><span class="co">   *</span></a>
<a class="sourceLine" id="cb15-5" title="5"><span class="co">   *  The vramSetPrimaryBanks function takes four arguments, one for each of</span></a>
<a class="sourceLine" id="cb15-6" title="6"><span class="co">   *  the major VRAM banks. We can use it as shorthand for assigning values to</span></a>
<a class="sourceLine" id="cb15-7" title="7"><span class="co">   *  each of the VRAM bank&#39;s control registers.</span></a>
<a class="sourceLine" id="cb15-8" title="8"><span class="co">   *</span></a>
<a class="sourceLine" id="cb15-9" title="9"><span class="co">   *  We map banks A and B to main screen  background memory. This gives us</span></a>
<a class="sourceLine" id="cb15-10" title="10"><span class="co">   *  256KB, which is a healthy amount for 16-bit graphics.</span></a>
<a class="sourceLine" id="cb15-11" title="11"><span class="co">   *</span></a>
<a class="sourceLine" id="cb15-12" title="12"><span class="co">   *  We map bank C to sub screen background memory.</span></a>
<a class="sourceLine" id="cb15-13" title="13"><span class="co">   *</span></a>
<a class="sourceLine" id="cb15-14" title="14"><span class="co">   *  We map bank D to LCD. This setting is generally used for when we aren&#39;t</span></a>
<a class="sourceLine" id="cb15-15" title="15"><span class="co">   *  using a particular bank.</span></a>
<a class="sourceLine" id="cb15-16" title="16"><span class="co">   *</span></a>
<a class="sourceLine" id="cb15-17" title="17"><span class="co">   *  We map bank E to main screen sprite memory (aka object memory).</span></a>
<a class="sourceLine" id="cb15-18" title="18"><span class="co">   */</span></a>
<a class="sourceLine" id="cb15-19" title="19">  vramSetPrimaryBanks(VRAM_A_MAIN_BG_0x06000000,</a>
<a class="sourceLine" id="cb15-20" title="20">                      VRAM_B_MAIN_BG_0x06020000,</a>
<a class="sourceLine" id="cb15-21" title="21">                      VRAM_C_SUB_BG_0x06200000,</a>
<a class="sourceLine" id="cb15-22" title="22">                      VRAM_D_LCD);</a>
<a class="sourceLine" id="cb15-23" title="23"></a>
<a class="sourceLine" id="cb15-24" title="24">  vramSetBankE(VRAM_E_MAIN_SPRITE);</a>
<a class="sourceLine" id="cb15-25" title="25"></a>
<a class="sourceLine" id="cb15-26" title="26">  <span class="co">/*  Set the video mode on the main screen. */</span></a>
<a class="sourceLine" id="cb15-27" title="27">  videoSetMode(MODE_5_2D | <span class="co">// Set the graphics mode to Mode 5</span></a>
<a class="sourceLine" id="cb15-28" title="28">         DISPLAY_BG2_ACTIVE | <span class="co">// Enable BG2 for display</span></a>
<a class="sourceLine" id="cb15-29" title="29">         DISPLAY_BG3_ACTIVE | <span class="co">// Enable BG3 for display</span></a>
<a class="sourceLine" id="cb15-30" title="30">         DISPLAY_SPR_ACTIVE | <span class="co">// Enable sprites for display</span></a>
<a class="sourceLine" id="cb15-31" title="31">         DISPLAY_SPR_1D     <span class="co">// Enable 1D tiled sprites</span></a>
<a class="sourceLine" id="cb15-32" title="32">         );</a>
<a class="sourceLine" id="cb15-33" title="33"></a>
<a class="sourceLine" id="cb15-34" title="34">  <span class="co">/*  Set the video mode on the sub screen. */</span></a>
<a class="sourceLine" id="cb15-35" title="35">  videoSetModeSub(MODE_5_2D | <span class="co">// Set the graphics mode to Mode 5</span></a>
<a class="sourceLine" id="cb15-36" title="36">          DISPLAY_BG3_ACTIVE); <span class="co">// Enable BG3 for display</span></a>
<a class="sourceLine" id="cb15-37" title="37">}</a>
<a class="sourceLine" id="cb15-38" title="38">      </a></code></pre></div>
<h2>Sprite Tile Addressing</h2>
<p>We'll be using the same memory alignment (boundary) as the GBA uses for our sprites. Tile VRAM addresses must be aligned to 32 bytes. If you feel shorted by this, since you can't use all 1024 addressable tiles when using 256 color tiles, for instance, then you can look up how to use other alignments at <a href="http://nocash.emubase.de/gbatek.htm#dsvideoobjs"></a>. You'll have to set REG_DISPCNT (via videoSetMode) with a value defined in <code>libnds/include/nds/arm9/video.h</code> akin to DISPLAY_SPR_1D_SIZE_XXX (the default, and the method the GBA and we use, is DISPLAY_SPR_1D_SIZE_32).</p>
<p>To compute the address to copy tiles to, we basically need to know two things: the memory alignment we are using and the tile numbers we want to assign data to. Using the formula from Martin Korth's GBATEK, "TileVramAddress = TileNumber * BoundaryValue", and libnds's SPRITE_GFX define we can compute the address of any tile as follows.</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode C++"><code class="sourceCode cpp"><a class="sourceLine" id="cb16-1" title="1"><span class="at">static</span> <span class="at">const</span> <span class="dt">int</span> BOUNDARY_VALUE = <span class="dv">32</span>; <span class="co">/* This is the default boundary value</span></a>
<a class="sourceLine" id="cb16-2" title="2"><span class="co">                     * (can be set in REG_DISPCNT) */</span></a>
<a class="sourceLine" id="cb16-3" title="3"><span class="at">static</span> <span class="at">const</span> <span class="dt">int</span> OFFSET_MULTIPLIER = BOUNDARY_VALUE /</a>
<a class="sourceLine" id="cb16-4" title="4">                   <span class="kw">sizeof</span>(SPRITE_GFX[<span class="dv">0</span>]);</a>
<a class="sourceLine" id="cb16-5" title="5">uint16 * tileVramAddress = &amp;SPRITE_GFX[shuttle-&gt;gfxIndex *</a>
<a class="sourceLine" id="cb16-6" title="6">                       OFFSET_MULTIPLIER];</a>
<a class="sourceLine" id="cb16-7" title="7">      </a></code></pre></div>
<p>We usually want to copy more than one tile into vram at a time, however. Luckily, when converting images to sprites with grit, it will tell us the length in bytes of our tile data for that sprite. After we have the length in bytes, we can use dmaCopyHalfwords (which uses byte lengths for copying) to copy the tile data into VRAM. We can also calculate how many tiles an image uses from its length in bytes by diving the length in bytes by how many bytes a tile takes up. In our case, as we'll be using 16-color tiles, a tile (8x8 pixels) takes up 32 bytes.</p>
<h2>Loading in a Sprite</h2>
<p>Now, to see a sprite in action. Let's load in the orangeShuttle graphic and the moon graphic. Make a new function called <code class="sourceCode cpp">initSprites</code>. Place it after the <code class="sourceCode cpp">initBackgrounds</code> function. Make sure to include <code>orangeShuttle.h</code> and <code>moon.h</code> now. They contain information about our sprites as generated by grit.</p>
<p>I've also create a new struct type called "SpriteInfo". This struct contains information about sprites that aren't explicitly contained in the SpriteEntry struct. We'll be using it to help us manage our information about sprites better.</p>
<p>We'll begin by filling in our SpriteInfo struct for the sprite. Each sprite will have its own SpriteInfo struct. The first thing we need to do is assign an OAM ID to the sprite. This number will help us keep track of which OAM entry our sprite is associated with. We'll also use it to compute other offsets, although we don't have to use it for that purpose in many cases.</p>
<p>Assign the width, height, and angle of the sprite.</p>
<p>Select an OAM entry to associate with this sprite.</p>
<p>Configure attribute 0.</p>
<p>Configure attribute 1.</p>
<p>Configure attribute 2.</p>
<p>Copy tile data to VRAM.</p>
<p>Copy the palette data to VRAM.</p>
<p>We'll just follow these steps twice when writing the initSprites function for our sprites. You can follow along with the comments and the code below.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode C++"><code class="sourceCode cpp"><a class="sourceLine" id="cb17-1" title="1"><span class="dt">void</span> initSprites(OAMTable * oam, SpriteInfo *spriteInfo) {</a>
<a class="sourceLine" id="cb17-2" title="2">  <span class="co">/*  Define some sprite configuration specific constants.</span></a>
<a class="sourceLine" id="cb17-3" title="3"><span class="co">   *</span></a>
<a class="sourceLine" id="cb17-4" title="4"><span class="co">   *  We will use these to compute the proper index into memory for certain</span></a>
<a class="sourceLine" id="cb17-5" title="5"><span class="co">   *  tiles or palettes.</span></a>
<a class="sourceLine" id="cb17-6" title="6"><span class="co">   *</span></a>
<a class="sourceLine" id="cb17-7" title="7"><span class="co">   *  OFFSET_MULTIPLIER is calculated based on the following formula from</span></a>
<a class="sourceLine" id="cb17-8" title="8"><span class="co">   *  GBATEK (http://nocash.emubase.de/gbatek.htm#dsvideoobjs):</span></a>
<a class="sourceLine" id="cb17-9" title="9"><span class="co">   *    TileVramAddress = TileNumber * BoundaryValue</span></a>
<a class="sourceLine" id="cb17-10" title="10"><span class="co">   *  Since SPRITE_GFX is a uint16*, the compiler will increment the address</span></a>
<a class="sourceLine" id="cb17-11" title="11"><span class="co">   *  it points to by 2 for each change in 1 of the array index into</span></a>
<a class="sourceLine" id="cb17-12" title="12"><span class="co">   *  SPRITE_GFX. (The compiler does pointer arithmetic.)</span></a>
<a class="sourceLine" id="cb17-13" title="13"><span class="co">   */</span></a>
<a class="sourceLine" id="cb17-14" title="14">  <span class="at">static</span> <span class="at">const</span> <span class="dt">int</span> BYTES_PER_16_COLOR_TILE = <span class="dv">32</span>;</a>
<a class="sourceLine" id="cb17-15" title="15">  <span class="at">static</span> <span class="at">const</span> <span class="dt">int</span> COLORS_PER_PALETTE = <span class="dv">16</span>;</a>
<a class="sourceLine" id="cb17-16" title="16">  <span class="at">static</span> <span class="at">const</span> <span class="dt">int</span> BOUNDARY_VALUE = <span class="dv">32</span>; <span class="co">/* This is the default boundary value</span></a>
<a class="sourceLine" id="cb17-17" title="17"><span class="co">                       * (can be set in REG_DISPCNT) */</span></a>
<a class="sourceLine" id="cb17-18" title="18">  <span class="at">static</span> <span class="at">const</span> <span class="dt">int</span> OFFSET_MULTIPLIER = BOUNDARY_VALUE /</a>
<a class="sourceLine" id="cb17-19" title="19">                     <span class="kw">sizeof</span>(SPRITE_GFX[<span class="dv">0</span>]);</a>
<a class="sourceLine" id="cb17-20" title="20"></a>
<a class="sourceLine" id="cb17-21" title="21">  <span class="co">/* Keep track of the available tiles */</span></a>
<a class="sourceLine" id="cb17-22" title="22">  <span class="dt">int</span> nextAvailableTileIdx = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb17-23" title="23"></a>
<a class="sourceLine" id="cb17-24" title="24">  <span class="co">/* Create the ship sprite. */</span></a>
<a class="sourceLine" id="cb17-25" title="25">  <span class="at">static</span> <span class="at">const</span> <span class="dt">int</span> SHUTTLE_OAM_ID = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb17-26" title="26">  <span class="ot">assert</span>(SHUTTLE_OAM_ID &lt; SPRITE_COUNT);</a>
<a class="sourceLine" id="cb17-27" title="27">  SpriteInfo * shuttleInfo = &amp;spriteInfo[SHUTTLE_OAM_ID];</a>
<a class="sourceLine" id="cb17-28" title="28">  SpriteEntry * shuttle = &amp;oam-&gt;oamBuffer[SHUTTLE_OAM_ID];</a>
<a class="sourceLine" id="cb17-29" title="29"></a>
<a class="sourceLine" id="cb17-30" title="30">  <span class="co">/* Initialize shuttleInfo */</span></a>
<a class="sourceLine" id="cb17-31" title="31">  shuttleInfo-&gt;oamId = SHUTTLE_OAM_ID;</a>
<a class="sourceLine" id="cb17-32" title="32">  shuttleInfo-&gt;width = <span class="dv">64</span>;</a>
<a class="sourceLine" id="cb17-33" title="33">  shuttleInfo-&gt;height = <span class="dv">64</span>;</a>
<a class="sourceLine" id="cb17-34" title="34">  shuttleInfo-&gt;angle = <span class="dv">462</span>;</a>
<a class="sourceLine" id="cb17-35" title="35">  shuttleInfo-&gt;entry = shuttle;</a>
<a class="sourceLine" id="cb17-36" title="36"></a>
<a class="sourceLine" id="cb17-37" title="37">  <span class="co">/*</span></a>
<a class="sourceLine" id="cb17-38" title="38"><span class="co">   *  Configure attribute 0.</span></a>
<a class="sourceLine" id="cb17-39" title="39"><span class="co">   *</span></a>
<a class="sourceLine" id="cb17-40" title="40"><span class="co">   *  OBJCOLOR_16 will make a 16-color sprite. We specify that we want an</span></a>
<a class="sourceLine" id="cb17-41" title="41"><span class="co">   *  affine sprite (via isRotateScale) here because we would like to rotate</span></a>
<a class="sourceLine" id="cb17-42" title="42"><span class="co">   *  the ship.</span></a>
<a class="sourceLine" id="cb17-43" title="43"><span class="co">   */</span></a>
<a class="sourceLine" id="cb17-44" title="44">  shuttle-&gt;y = SCREEN_HEIGHT / <span class="dv">2</span> - shuttleInfo-&gt;height;</a>
<a class="sourceLine" id="cb17-45" title="45">  shuttle-&gt;isRotateScale = <span class="kw">true</span>;</a>
<a class="sourceLine" id="cb17-46" title="46">  <span class="co">/* This assert is a check to see a matrix is available to store the affine</span></a>
<a class="sourceLine" id="cb17-47" title="47"><span class="co">   * transformation matrix for this sprite. Of course, you don&#39;t have to have</span></a>
<a class="sourceLine" id="cb17-48" title="48"><span class="co">   * the matrix id match the affine id, but if you do make them match, this</span></a>
<a class="sourceLine" id="cb17-49" title="49"><span class="co">   * assert can be helpful. */</span></a>
<a class="sourceLine" id="cb17-50" title="50">  <span class="ot">assert</span>(!shuttle-&gt;isRotateScale || (shuttleInfo-&gt;oamId &lt; MATRIX_COUNT));</a>
<a class="sourceLine" id="cb17-51" title="51">  shuttle-&gt;isSizeDouble = <span class="kw">false</span>;</a>
<a class="sourceLine" id="cb17-52" title="52">  shuttle-&gt;blendMode = OBJMODE_NORMAL;</a>
<a class="sourceLine" id="cb17-53" title="53">  shuttle-&gt;isMosaic = <span class="kw">false</span>;</a>
<a class="sourceLine" id="cb17-54" title="54">  shuttle-&gt;colorMode = OBJCOLOR_16;</a>
<a class="sourceLine" id="cb17-55" title="55">  shuttle-&gt;shape = OBJSHAPE_SQUARE;</a>
<a class="sourceLine" id="cb17-56" title="56"></a>
<a class="sourceLine" id="cb17-57" title="57">  <span class="co">/*</span></a>
<a class="sourceLine" id="cb17-58" title="58"><span class="co">   *  Configure attribute 1.</span></a>
<a class="sourceLine" id="cb17-59" title="59"><span class="co">   *</span></a>
<a class="sourceLine" id="cb17-60" title="60"><span class="co">   *  rotationIndex refers to the loation of affine transformation matrix. We</span></a>
<a class="sourceLine" id="cb17-61" title="61"><span class="co">   *  set it to a location computed with a macro. OBJSIZE_64, in our case</span></a>
<a class="sourceLine" id="cb17-62" title="62"><span class="co">   *  since we are making a square sprite, creates a 64x64 sprite.</span></a>
<a class="sourceLine" id="cb17-63" title="63"><span class="co">   */</span></a>
<a class="sourceLine" id="cb17-64" title="64">  shuttle-&gt;x = SCREEN_WIDTH / <span class="dv">2</span> - shuttleInfo-&gt;width * <span class="dv">2</span> +</a>
<a class="sourceLine" id="cb17-65" title="65">          shuttleInfo-&gt;width / <span class="dv">2</span>;</a>
<a class="sourceLine" id="cb17-66" title="66">  shuttle-&gt;rotationIndex = shuttleInfo-&gt;oamId;</a>
<a class="sourceLine" id="cb17-67" title="67">  shuttle-&gt;size = OBJSIZE_64;</a>
<a class="sourceLine" id="cb17-68" title="68"></a>
<a class="sourceLine" id="cb17-69" title="69">  <span class="co">/*</span></a>
<a class="sourceLine" id="cb17-70" title="70"><span class="co">   *  Configure attribute 2.</span></a>
<a class="sourceLine" id="cb17-71" title="71"><span class="co">   *</span></a>
<a class="sourceLine" id="cb17-72" title="72"><span class="co">   *  Configure which tiles the sprite will use, which priority layer it will</span></a>
<a class="sourceLine" id="cb17-73" title="73"><span class="co">   *  be placed onto, which palette the sprite should use, and whether or not</span></a>
<a class="sourceLine" id="cb17-74" title="74"><span class="co">   *  to show the sprite.</span></a>
<a class="sourceLine" id="cb17-75" title="75"><span class="co">   */</span></a>
<a class="sourceLine" id="cb17-76" title="76">  shuttle-&gt;gfxIndex = nextAvailableTileIdx;</a>
<a class="sourceLine" id="cb17-77" title="77">  nextAvailableTileIdx += orangeShuttleTilesLen / BYTES_PER_16_COLOR_TILE;</a>
<a class="sourceLine" id="cb17-78" title="78">  shuttle-&gt;priority = OBJPRIORITY_0;</a>
<a class="sourceLine" id="cb17-79" title="79">  shuttle-&gt;palette = shuttleInfo-&gt;oamId;</a>
<a class="sourceLine" id="cb17-80" title="80"></a>
<a class="sourceLine" id="cb17-81" title="81">  <span class="co">/* Rotate the sprite */</span></a>
<a class="sourceLine" id="cb17-82" title="82">  rotateSprite(&amp;oam-&gt;matrixBuffer[shuttleInfo-&gt;oamId],</a>
<a class="sourceLine" id="cb17-83" title="83">         shuttleInfo-&gt;angle);</a>
<a class="sourceLine" id="cb17-84" title="84"></a>
<a class="sourceLine" id="cb17-85" title="85">  <span class="co">/*************************************************************************/</span></a>
<a class="sourceLine" id="cb17-86" title="86"></a>
<a class="sourceLine" id="cb17-87" title="87">  <span class="co">/* Create the moon sprite. */</span></a>
<a class="sourceLine" id="cb17-88" title="88">  <span class="at">static</span> <span class="at">const</span> <span class="dt">int</span> MOON_OAM_ID = <span class="dv">1</span>;</a>
<a class="sourceLine" id="cb17-89" title="89">  <span class="ot">assert</span>(MOON_OAM_ID &lt; SPRITE_COUNT);</a>
<a class="sourceLine" id="cb17-90" title="90">  SpriteInfo * moonInfo = &amp;spriteInfo[MOON_OAM_ID];</a>
<a class="sourceLine" id="cb17-91" title="91">  SpriteEntry * moon = &amp;oam-&gt;oamBuffer[MOON_OAM_ID];</a>
<a class="sourceLine" id="cb17-92" title="92"></a>
<a class="sourceLine" id="cb17-93" title="93">  <span class="co">/* Initialize moonInfo */</span></a>
<a class="sourceLine" id="cb17-94" title="94">  moonInfo-&gt;oamId = MOON_OAM_ID;</a>
<a class="sourceLine" id="cb17-95" title="95">  moonInfo-&gt;width = <span class="dv">32</span>;</a>
<a class="sourceLine" id="cb17-96" title="96">  moonInfo-&gt;height = <span class="dv">32</span>;</a>
<a class="sourceLine" id="cb17-97" title="97">  moonInfo-&gt;angle = <span class="dv">462</span>;</a>
<a class="sourceLine" id="cb17-98" title="98">  moonInfo-&gt;entry = moon;</a>
<a class="sourceLine" id="cb17-99" title="99"></a>
<a class="sourceLine" id="cb17-100" title="100">  <span class="co">/*</span></a>
<a class="sourceLine" id="cb17-101" title="101"><span class="co">   *  Configure attribute 0.</span></a>
<a class="sourceLine" id="cb17-102" title="102"><span class="co">   *</span></a>
<a class="sourceLine" id="cb17-103" title="103"><span class="co">   *  OBJCOLOR_16 will make a 16-color sprite. We won&#39;t specify that we want</span></a>
<a class="sourceLine" id="cb17-104" title="104"><span class="co">   *  an affine sprite here because we don&#39;t want one this time.</span></a>
<a class="sourceLine" id="cb17-105" title="105"><span class="co">   */</span></a>
<a class="sourceLine" id="cb17-106" title="106">  moon-&gt;y = SCREEN_WIDTH / <span class="dv">2</span> + moonInfo-&gt;height / <span class="dv">2</span>;</a>
<a class="sourceLine" id="cb17-107" title="107">  moon-&gt;isRotateScale = <span class="kw">false</span>;</a>
<a class="sourceLine" id="cb17-108" title="108">  <span class="co">/* This assert is a check to see a matrix is available to store the affine</span></a>
<a class="sourceLine" id="cb17-109" title="109"><span class="co">   * transformation matrix for this sprite. Of course, you don&#39;t have to have</span></a>
<a class="sourceLine" id="cb17-110" title="110"><span class="co">   * the matrix id match the affine id, but if you do make them match, this</span></a>
<a class="sourceLine" id="cb17-111" title="111"><span class="co">   * assert can be helpful. */</span></a>
<a class="sourceLine" id="cb17-112" title="112">  <span class="ot">assert</span>(!moon-&gt;isRotateScale || (moonInfo-&gt;oamId &lt; MATRIX_COUNT));</a>
<a class="sourceLine" id="cb17-113" title="113">  moon-&gt;isHidden = <span class="kw">false</span>;</a>
<a class="sourceLine" id="cb17-114" title="114">  moon-&gt;blendMode = OBJMODE_NORMAL;</a>
<a class="sourceLine" id="cb17-115" title="115">  moon-&gt;isMosaic = <span class="kw">false</span>;</a>
<a class="sourceLine" id="cb17-116" title="116">  moon-&gt;colorMode = OBJCOLOR_16;</a>
<a class="sourceLine" id="cb17-117" title="117">  moon-&gt;shape = OBJSHAPE_SQUARE;</a>
<a class="sourceLine" id="cb17-118" title="118"></a>
<a class="sourceLine" id="cb17-119" title="119">  <span class="co">/*</span></a>
<a class="sourceLine" id="cb17-120" title="120"><span class="co">   * Configure attribute 1.</span></a>
<a class="sourceLine" id="cb17-121" title="121"><span class="co">   *</span></a>
<a class="sourceLine" id="cb17-122" title="122"><span class="co">   * OBJSIZE_32 will create a sprite of size 32x32, since we are making a</span></a>
<a class="sourceLine" id="cb17-123" title="123"><span class="co">   * square sprite. Since we are using a non-affine sprite, attribute 1</span></a>
<a class="sourceLine" id="cb17-124" title="124"><span class="co">   * doesn&#39;t have an rotationIndex anymore. Instead, it has the ability to</span></a>
<a class="sourceLine" id="cb17-125" title="125"><span class="co">   * flip the sprite vertically or horizontally.</span></a>
<a class="sourceLine" id="cb17-126" title="126"><span class="co">   */</span></a>
<a class="sourceLine" id="cb17-127" title="127">  moon-&gt;x = SCREEN_WIDTH / <span class="dv">2</span> + moonInfo-&gt;width + moonInfo-&gt;width / <span class="dv">2</span>;</a>
<a class="sourceLine" id="cb17-128" title="128">  moon-&gt;hFlip = <span class="kw">false</span>;</a>
<a class="sourceLine" id="cb17-129" title="129">  moon-&gt;vFlip = <span class="kw">false</span>;</a>
<a class="sourceLine" id="cb17-130" title="130">  moon-&gt;size = OBJSIZE_32;</a>
<a class="sourceLine" id="cb17-131" title="131"></a>
<a class="sourceLine" id="cb17-132" title="132">  <span class="co">/*</span></a>
<a class="sourceLine" id="cb17-133" title="133"><span class="co">   *  Configure attribute 2.</span></a>
<a class="sourceLine" id="cb17-134" title="134"><span class="co">   *</span></a>
<a class="sourceLine" id="cb17-135" title="135"><span class="co">   *  Configure which tiles the sprite will use, which priority layer it will</span></a>
<a class="sourceLine" id="cb17-136" title="136"><span class="co">   *  be placed onto, which palette the sprite should use, and whether or not</span></a>
<a class="sourceLine" id="cb17-137" title="137"><span class="co">   *  to show the sprite.</span></a>
<a class="sourceLine" id="cb17-138" title="138"><span class="co">   */</span></a>
<a class="sourceLine" id="cb17-139" title="139">  moon-&gt;gfxIndex = nextAvailableTileIdx;</a>
<a class="sourceLine" id="cb17-140" title="140">  nextAvailableTileIdx += moonTilesLen / BYTES_PER_16_COLOR_TILE;</a>
<a class="sourceLine" id="cb17-141" title="141">  moon-&gt;priority = OBJPRIORITY_2;</a>
<a class="sourceLine" id="cb17-142" title="142">  moon-&gt;palette = moonInfo-&gt;oamId;</a>
<a class="sourceLine" id="cb17-143" title="143"></a>
<a class="sourceLine" id="cb17-144" title="144">  <span class="co">/*************************************************************************/</span></a>
<a class="sourceLine" id="cb17-145" title="145"></a>
<a class="sourceLine" id="cb17-146" title="146">  <span class="co">/* Copy over the sprite palettes */</span></a>
<a class="sourceLine" id="cb17-147" title="147">  dmaCopyHalfWords(SPRITE_DMA_CHANNEL,</a>
<a class="sourceLine" id="cb17-148" title="148">           orangeShuttlePal,</a>
<a class="sourceLine" id="cb17-149" title="149">           &amp;SPRITE_PALETTE[shuttleInfo-&gt;oamId *</a>
<a class="sourceLine" id="cb17-150" title="150">                   COLORS_PER_PALETTE],</a>
<a class="sourceLine" id="cb17-151" title="151">           orangeShuttlePalLen);</a>
<a class="sourceLine" id="cb17-152" title="152">  dmaCopyHalfWords(SPRITE_DMA_CHANNEL,</a>
<a class="sourceLine" id="cb17-153" title="153">           moonPal,</a>
<a class="sourceLine" id="cb17-154" title="154">           &amp;SPRITE_PALETTE[moonInfo-&gt;oamId * COLORS_PER_PALETTE],</a>
<a class="sourceLine" id="cb17-155" title="155">           moonPalLen);</a>
<a class="sourceLine" id="cb17-156" title="156"></a>
<a class="sourceLine" id="cb17-157" title="157">  <span class="co">/* Copy the sprite graphics to sprite graphics memory */</span></a>
<a class="sourceLine" id="cb17-158" title="158">  dmaCopyHalfWords(SPRITE_DMA_CHANNEL,</a>
<a class="sourceLine" id="cb17-159" title="159">           orangeShuttleTiles,</a>
<a class="sourceLine" id="cb17-160" title="160">           &amp;SPRITE_GFX[shuttle-&gt;gfxIndex * OFFSET_MULTIPLIER],</a>
<a class="sourceLine" id="cb17-161" title="161">           orangeShuttleTilesLen);</a>
<a class="sourceLine" id="cb17-162" title="162">  dmaCopyHalfWords(SPRITE_DMA_CHANNEL,</a>
<a class="sourceLine" id="cb17-163" title="163">           moonTiles,</a>
<a class="sourceLine" id="cb17-164" title="164">           &amp;SPRITE_GFX[moon-&gt;gfxIndex * OFFSET_MULTIPLIER],</a>
<a class="sourceLine" id="cb17-165" title="165">           moonTilesLen);</a>
<a class="sourceLine" id="cb17-166" title="166">}</a>
<a class="sourceLine" id="cb17-167" title="167">      </a></code></pre></div>
<h2>What are assertions?</h2>
<p>In the above code, you'll find some things that look like function calls to a function called <code class="sourceCode cpp"><span class="ot">assert</span></code>. These aren't actually function calls, but macro expansions. You'll have to include <code>assert.h</code> in order to use them.</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode C++"><code class="sourceCode cpp"><a class="sourceLine" id="cb18-1" title="1"><span class="pp">#include </span><span class="im">&lt;assert.h&gt;</span></a>
<a class="sourceLine" id="cb18-2" title="2">      </a></code></pre></div>
<p>The assert macro allows the programmer to make assumptions about what is going on in the code. To use them, you just place some kind of "fact" in between the paranthesis. Whenever this assumption fails, the program will quit. Assertions are evaluated at runtime.</p>
<p>Assertions help you avoid developing obscure bugs later on since they'll stop them right where something first goes wrong. Assertions are a good thing and should be used often.</p>
<p>When you release a production version of your software, the assertions can be removed from your code by the preprocessor. To do this with a GNU compiler, like the ones we are using, you simply set NDEBUG.</p>
<h2>Displaying the Sprites</h2>
<p>In our main function, we now need to initialize our copy of the OAM, create the structs which hold our sprite data, make a call to the <code class="sourceCode cpp">initSprites</code> function we just created, and then update the OAM by copying our OAM copy to OAM.</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode C++"><code class="sourceCode cpp"><a class="sourceLine" id="cb19-1" title="1"><span class="dt">int</span> main() {</a>
<a class="sourceLine" id="cb19-2" title="2">  <span class="co">/*  Turn on the 2D graphics core. */</span></a>
<a class="sourceLine" id="cb19-3" title="3">  powerOn(POWER_ALL_2D);</a>
<a class="sourceLine" id="cb19-4" title="4"></a>
<a class="sourceLine" id="cb19-5" title="5">  <span class="co">/*</span></a>
<a class="sourceLine" id="cb19-6" title="6"><span class="co">   *  Configure the VRAM and background control registers.</span></a>
<a class="sourceLine" id="cb19-7" title="7"><span class="co">   *</span></a>
<a class="sourceLine" id="cb19-8" title="8"><span class="co">   *  Place the main screen on the bottom physical screen. Then arrange the</span></a>
<a class="sourceLine" id="cb19-9" title="9"><span class="co">   *  VRAM banks. Next, confiure the background control registers.</span></a>
<a class="sourceLine" id="cb19-10" title="10"><span class="co">   */</span></a>
<a class="sourceLine" id="cb19-11" title="11">  lcdMainOnBottom();</a>
<a class="sourceLine" id="cb19-12" title="12">  initVideo();</a>
<a class="sourceLine" id="cb19-13" title="13">  initBackgrounds();</a>
<a class="sourceLine" id="cb19-14" title="14"></a>
<a class="sourceLine" id="cb19-15" title="15">  <span class="co">/* Set up a few sprites. */</span></a>
<a class="sourceLine" id="cb19-16" title="16">  SpriteInfo spriteInfo[SPRITE_COUNT];</a>
<a class="sourceLine" id="cb19-17" title="17">  OAMTable *oam = <span class="kw">new</span> OAMTable();</a>
<a class="sourceLine" id="cb19-18" title="18">  iniOAMTable(oam);</a>
<a class="sourceLine" id="cb19-19" title="19">  initSprites(oam, spriteInfo);</a>
<a class="sourceLine" id="cb19-20" title="20"></a>
<a class="sourceLine" id="cb19-21" title="21">  <span class="co">/* Display the backgrounds. */</span></a>
<a class="sourceLine" id="cb19-22" title="22">  displayStarField();</a>
<a class="sourceLine" id="cb19-23" title="23">  displayPlanet();</a>
<a class="sourceLine" id="cb19-24" title="24">  displaySplash();</a>
<a class="sourceLine" id="cb19-25" title="25"></a>
<a class="sourceLine" id="cb19-26" title="26">  <span class="co">/*</span></a>
<a class="sourceLine" id="cb19-27" title="27"><span class="co">   *  Update the OAM.</span></a>
<a class="sourceLine" id="cb19-28" title="28"><span class="co">   *</span></a>
<a class="sourceLine" id="cb19-29" title="29"><span class="co">   *  We have to copy our copy of OAM data into the actual</span></a>
<a class="sourceLine" id="cb19-30" title="30"><span class="co">   *  OAM during VBlank (writes to it are locked during</span></a>
<a class="sourceLine" id="cb19-31" title="31"><span class="co">   *  other times).</span></a>
<a class="sourceLine" id="cb19-32" title="32"><span class="co">   */</span></a>
<a class="sourceLine" id="cb19-33" title="33">  swiWaitForVBlank();</a>
<a class="sourceLine" id="cb19-34" title="34">  updateOAM(oam);</a>
<a class="sourceLine" id="cb19-35" title="35"></a>
<a class="sourceLine" id="cb19-36" title="36">  <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb19-37" title="37">}</a>
<a class="sourceLine" id="cb19-38" title="38">      </a></code></pre></div>
<h2>Compiling</h2>
<p>Before you get to compiling, you may want to look at the top of your <code>main.cpp</code> file and verify that you are including all the proper files. There are a lot of files to include now, so it is easy to lose track of which ones we need. (I probably even forgot to let you know about some of them.)</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode C++"><code class="sourceCode cpp"><a class="sourceLine" id="cb20-1" title="1"><span class="pp">#include </span><span class="im">&lt;nds.h&gt;</span></a>
<a class="sourceLine" id="cb20-2" title="2"><span class="pp">#include </span><span class="im">&lt;assert.h&gt;</span></a>
<a class="sourceLine" id="cb20-3" title="3"><span class="pp">#include </span><span class="im">&quot;sprites.h&quot;</span></a>
<a class="sourceLine" id="cb20-4" title="4"></a>
<a class="sourceLine" id="cb20-5" title="5"><span class="co">/* Backgrounds */</span></a>
<a class="sourceLine" id="cb20-6" title="6"><span class="pp">#include </span><span class="im">&quot;starField.h&quot;</span></a>
<a class="sourceLine" id="cb20-7" title="7"><span class="pp">#include </span><span class="im">&quot;planet.h&quot;</span></a>
<a class="sourceLine" id="cb20-8" title="8"><span class="pp">#include </span><span class="im">&quot;splash.h&quot;</span></a>
<a class="sourceLine" id="cb20-9" title="9"><span class="co">/* Sprites */</span></a>
<a class="sourceLine" id="cb20-10" title="10"><span class="pp">#include </span><span class="im">&quot;orangeShuttle.h&quot;</span></a>
<a class="sourceLine" id="cb20-11" title="11"><span class="pp">#include </span><span class="im">&quot;moon.h&quot;</span></a>
<a class="sourceLine" id="cb20-12" title="12">      </a></code></pre></div>
<p>If all goes well, you’ll compile with no problems and the output will look as in <a href="#chapter_6_screen_shot">figure_title</a>.</p>
<figure>
<img src="images/splash.png" alt="Output with both backgrounds and a sprite." /><figcaption>Output with both backgrounds and a sprite.</figcaption>
</figure>
<figure>
<img src="images/starfield_and_orange_shuttle.png" alt="Output with both backgrounds and a sprite." /><figcaption>Output with both backgrounds and a sprite.</figcaption>
</figure>
<h1>Basic Game Mechanics Applied to the Space Shooter Genre</h1>
<h2>The Importance of Object Oriented Programming</h2>
<p>Object oriented programming (OOP) is essential to making good games on a modern system. Although it is very much possible without object oriented programming, OOP is an incredible tool that greatly improves code reusability, readability, modularization, and abstraction. It makes the programmer's job a lot easier. Also, due to modularization, collaborating on projects with your friends or coworkers is easily ten fold easier.</p>
<h2>The Ship Class</h2>
<p>The first thing we'll make is a Ship class. This class will encapsulate all the properties and functionality of any ship in an easy to use and understand format. Think of things a ship can do, on a high level. What should come to mind is the ability to turn both ways, shoot weapons, accelerate, move at a given velocity (coasting), and maybe some more things if you are creative enough. What properties of a ship can you come up with? Perhaps turning speed, thrust, mass, maximum speed, velocity, position, shields? Well, after you are done brainstorming, the next step is to write out the functionality and properties we need to put into our Ship class. You could make a table, as in <a href="#ship_properties_and_functions">table_title</a>, or draw some diagrams on a piece of paper. Either way, you want to make sure your ideas all get onto some physical paper before you begin coding.</p>
<table>
<caption>Table of Ship properties and functionality.</caption>
<thead>
<tr class="header">
<th>Properties</th>
<th>Functionality</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>shipHeight</td>
<td>accelerate</td>
</tr>
<tr class="even">
<td>shipWidth</td>
<td>moveShip</td>
</tr>
<tr class="odd">
<td>position</td>
<td>turnClockwise</td>
</tr>
<tr class="even">
<td>velocity</td>
<td>turnCounterClockwise</td>
</tr>
<tr class="odd">
<td>angle</td>
<td>getPosition</td>
</tr>
<tr class="even">
<td>turnSpeed</td>
<td>reverseTurn</td>
</tr>
<tr class="odd">
<td>thrust</td>
<td>getAngle</td>
</tr>
<tr class="even">
<td>maxSpeed</td>
<td></td>
</tr>
<tr class="odd">
<td>mass</td>
<td></td>
</tr>
</tbody>
</table>
<h2>Making the Ship Class</h2>
<p>I have provided a skeleton framework file for you to write your class in. It is all set and ready for you to implement in the <code>ship.cpp</code> file. The header file, <code>ship.h</code> is also included. On your own, with your own classes in the future, you should always make a skeleton framework class to work from. It makes implementation straightforward and you do not have to worry about the semantics of setting up a class so much.</p>
<h2>The Constructor</h2>
<p>I have provided you with a simple constructor and private initialization method method. These are often mundane things to make. In fact, the compiler will automatically make the constructor, copy constructor, and operator= methods for you if you don't explicitly make them. Feel free to modify the default values in the initializers to try out different effects of changing the ship properties.</p>
<h2>Acceleration</h2>
<p>Acceleration is probably one of the most important things your ships can do. To accelerate, we simply increase our velocity by a certain increment, that being the thrust capability of the ship, in the angle we are headed. Here is where some simple trigonometry comes into play. Since our velocity is stored as a two dimensional vecotr (x and y component), we have to shadow our thrust vector onto each direction. We do this we multiply the thrust by sin(angle) for our x component, and by -cos(angle) for the y direction. Next, after we have computed the increment for both x and y, we add them onto our current velocity, making sure we don’t go over the ship's maximum speed.</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode C++"><code class="sourceCode cpp"><a class="sourceLine" id="cb21-1" title="1"><span class="dt">void</span> Ship::accelerate() {</a>
<a class="sourceLine" id="cb21-2" title="2">  <span class="dt">float</span> incX = thrust * sin(angle);</a>
<a class="sourceLine" id="cb21-3" title="3">  <span class="dt">float</span> incY = -(thrust * cos(angle));</a>
<a class="sourceLine" id="cb21-4" title="4"></a>
<a class="sourceLine" id="cb21-5" title="5">  <span class="co">//the following method of speed limitation is not accurate, traveling</span></a>
<a class="sourceLine" id="cb21-6" title="6">  <span class="co">//diagonally is faster than straight, which is not the desired limitation</span></a>
<a class="sourceLine" id="cb21-7" title="7">  <span class="co">//a more accurate method is needed at a later time</span></a>
<a class="sourceLine" id="cb21-8" title="8"></a>
<a class="sourceLine" id="cb21-9" title="9">  velocity.x += incX;</a>
<a class="sourceLine" id="cb21-10" title="10">  <span class="co">//make sure can&#39;t go too fast in x direction</span></a>
<a class="sourceLine" id="cb21-11" title="11">  <span class="cf">if</span> (velocity.x &gt; maxSpeed) {</a>
<a class="sourceLine" id="cb21-12" title="12">    velocity.x = maxSpeed;</a>
<a class="sourceLine" id="cb21-13" title="13">  }</a>
<a class="sourceLine" id="cb21-14" title="14">  <span class="cf">if</span> (velocity.x &lt; -maxSpeed) {</a>
<a class="sourceLine" id="cb21-15" title="15">    velocity.x = -maxSpeed;</a>
<a class="sourceLine" id="cb21-16" title="16">  }</a>
<a class="sourceLine" id="cb21-17" title="17"></a>
<a class="sourceLine" id="cb21-18" title="18">  velocity.y += incY;</a>
<a class="sourceLine" id="cb21-19" title="19">  <span class="co">//make sure can&#39;t go too fast in y direction</span></a>
<a class="sourceLine" id="cb21-20" title="20">  <span class="cf">if</span> (velocity.y &gt; maxSpeed) {</a>
<a class="sourceLine" id="cb21-21" title="21">    velocity.y = maxSpeed;</a>
<a class="sourceLine" id="cb21-22" title="22">  }</a>
<a class="sourceLine" id="cb21-23" title="23">  <span class="cf">if</span> (velocity.y &lt; -maxSpeed) {</a>
<a class="sourceLine" id="cb21-24" title="24">    velocity.y = -maxSpeed;</a>
<a class="sourceLine" id="cb21-25" title="25">  }</a>
<a class="sourceLine" id="cb21-26" title="26">}</a>
<a class="sourceLine" id="cb21-27" title="27">      </a></code></pre></div>
<h2>Moving the Ship</h2>
<p>This one is incredibly easy thanks to the Nintendo DS hardware. All we have to do is increment our position by our velocity. The hardware takes care of any wrapping or offscreen issues.</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode C++"><code class="sourceCode cpp"><a class="sourceLine" id="cb22-1" title="1"><span class="dt">void</span> Ship::moveShip() {</a>
<a class="sourceLine" id="cb22-2" title="2">  <span class="co">//move the ship</span></a>
<a class="sourceLine" id="cb22-3" title="3">  position.x += velocity.x;</a>
<a class="sourceLine" id="cb22-4" title="4">  position.y += velocity.y;</a>
<a class="sourceLine" id="cb22-5" title="5"></a>
<a class="sourceLine" id="cb22-6" title="6">  <span class="co">//hw does wrap around for us, so we don&#39;t have to have any of that sort of</span></a>
<a class="sourceLine" id="cb22-7" title="7">  <span class="co">//logic in here</span></a>
<a class="sourceLine" id="cb22-8" title="8">}</a>
<a class="sourceLine" id="cb22-9" title="9">      </a></code></pre></div>
<h2>Reversing the Ship's Direction</h2>
<p>This one took me a while to figure out, even though it's just one line, but it's very useful. We can turn the ship around, not a 180 per se, but simply pointing into the opposite direction of our current velocity. This will get the angle of our velocity with respect to 0 degrees, and then will do a 180 from that angle.</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode C++"><code class="sourceCode cpp"><a class="sourceLine" id="cb23-1" title="1"><span class="dt">void</span> Ship::reverseTurn() {</a>
<a class="sourceLine" id="cb23-2" title="2">  angle = (<span class="dv">2</span> * PI) - atan2(velocity.x, velocity.y);</a>
<a class="sourceLine" id="cb23-3" title="3">}</a>
<a class="sourceLine" id="cb23-4" title="4">      </a></code></pre></div>
<h2>Rotating the Ship</h2>
<p>Rotating the ship is also quite simple. We just increment or by ship’s turning speed depending on which direction we wish to turn. Note that we are storing the angle of the ship as a clockwise rotation. This will be important to remember for later when we update the ship sprite.</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode C++"><code class="sourceCode cpp"><a class="sourceLine" id="cb24-1" title="1"><span class="dt">void</span> Ship::turnClockwise() {</a>
<a class="sourceLine" id="cb24-2" title="2">    angle += turnSpeed;</a>
<a class="sourceLine" id="cb24-3" title="3">}</a>
<a class="sourceLine" id="cb24-4" title="4"><span class="dt">void</span> Ship::turnCounterClockwise() {</a>
<a class="sourceLine" id="cb24-5" title="5">    angle -= turnSpeed;</a>
<a class="sourceLine" id="cb24-6" title="6">}</a>
<a class="sourceLine" id="cb24-7" title="7">      </a></code></pre></div>
<h2>Getting the Ship's Position</h2>
<p>Return the ship’s position.</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode C++"><code class="sourceCode cpp"><a class="sourceLine" id="cb25-1" title="1">MathVector2D&lt;<span class="dt">float</span>&gt; Ship::getPosition() {</a>
<a class="sourceLine" id="cb25-2" title="2">    <span class="cf">return</span> position;</a>
<a class="sourceLine" id="cb25-3" title="3">}</a>
<a class="sourceLine" id="cb25-4" title="4">      </a></code></pre></div>
<h2>Getting the Ship's Angle</h2>
<p>This one is a bit more tricky and involved. I suppose I should start by explaining that a Nintendo DS circle has 32768 degrees. It doesn't actually have 32768 degrees, nor does a Nintendo DS even know what a circle is, but it is easy to understand the hardware a bit better when we think of it this way. I will say, however, that the reason for the 32768 degrees is due to libnds's built-in look up tables for the sin and cos functions. Having only 360 entries in your lookup table would be a waste of space when it takes just as many bits to index into a 360 entry table as it does a 512 entry one. libnds gives us more accuracy by presenting a 32768 entry one. More entries allow finer accuracy. In order for the Nintendo DS to know how to rotate our sprites, we have to convert the internally stored radian angle value to a value within the 32768 degree system. This is an easy conversion.</p>
<p>The first step is to convert to a 360 degree system, as you must have learned in junior high school. This is done by multiplying the radian value by 180/PI. The 180 part is half the number of degrees in a circle. So, in a 32768 degree system we can convert by multiplying the radian value by DEGREES_IN_A_CIRCLE/(2 * PI). Lastly, just return that value as an integer. (The hardware does not have any floating point, so when rotating our sprites, we use a fixed point value disguised as an ordinary integer.)</p>
<p>Then, we make a function to return a converted angle value, for whenever we need it.</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode C++"><code class="sourceCode cpp"><a class="sourceLine" id="cb26-1" title="1"><span class="dt">int</span> Ship::radToDeg(<span class="dt">float</span> rad) {</a>
<a class="sourceLine" id="cb26-2" title="2">    <span class="cf">return</span> (<span class="dt">int</span>)(rad * (DEGREES_IN_A_CIRCLE/(<span class="dv">2</span> * PI)));</a>
<a class="sourceLine" id="cb26-3" title="3">}</a>
<a class="sourceLine" id="cb26-4" title="4"><span class="dt">int</span> Ship::getAngleDeg() {</a>
<a class="sourceLine" id="cb26-5" title="5">    <span class="cf">return</span> radToDeg(angle);</a>
<a class="sourceLine" id="cb26-6" title="6">}</a>
<a class="sourceLine" id="cb26-7" title="7">      </a></code></pre></div>
<h2>Linking the Ship into our Program</h2>
<p>We now need to create an instance of the ship in our main function. Creating an instance of a class, known as an object, is quite simple, as you can see below. We just have to create the Ship object and then assign a SpriteEntry to it.</p>
<p>We should also do something nifty with our new class so that we can verify that what we wrote is working. Let's make the ship move around on its own by telling the ship to trust ten times.</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode C++"><code class="sourceCode cpp"><a class="sourceLine" id="cb27-1" title="1"><span class="dt">int</span> main() {</a>
<a class="sourceLine" id="cb27-2" title="2">  <span class="co">/*  Turn on the 2D graphics core. */</span></a>
<a class="sourceLine" id="cb27-3" title="3">  powerOn(POWER_ALL_2D);</a>
<a class="sourceLine" id="cb27-4" title="4"></a>
<a class="sourceLine" id="cb27-5" title="5">  <span class="co">/*</span></a>
<a class="sourceLine" id="cb27-6" title="6"><span class="co">   *  Configure the VRAM and background control registers.</span></a>
<a class="sourceLine" id="cb27-7" title="7"><span class="co">   *</span></a>
<a class="sourceLine" id="cb27-8" title="8"><span class="co">   *  Place the main screen on the bottom physical screen. Then arrange the</span></a>
<a class="sourceLine" id="cb27-9" title="9"><span class="co">   *  VRAM banks. Next, confiure the background control registers.</span></a>
<a class="sourceLine" id="cb27-10" title="10"><span class="co">   */</span></a>
<a class="sourceLine" id="cb27-11" title="11">  lcdMainOnBottom();</a>
<a class="sourceLine" id="cb27-12" title="12">  initVideo();</a>
<a class="sourceLine" id="cb27-13" title="13">  initBackgrounds();</a>
<a class="sourceLine" id="cb27-14" title="14"></a>
<a class="sourceLine" id="cb27-15" title="15">  <span class="co">/* Set up a few sprites. */</span></a>
<a class="sourceLine" id="cb27-16" title="16">  SpriteInfo spriteInfo[SPRITE_COUNT];</a>
<a class="sourceLine" id="cb27-17" title="17">  OAMTable *oam = <span class="kw">new</span> OAMTable();</a>
<a class="sourceLine" id="cb27-18" title="18">  iniOAMTable(oam);</a>
<a class="sourceLine" id="cb27-19" title="19">  initSprites(oam, spriteInfo);</a>
<a class="sourceLine" id="cb27-20" title="20"></a>
<a class="sourceLine" id="cb27-21" title="21">  <span class="co">/* Display the backgrounds. */</span></a>
<a class="sourceLine" id="cb27-22" title="22">  displayStarField();</a>
<a class="sourceLine" id="cb27-23" title="23">  displayPlanet();</a>
<a class="sourceLine" id="cb27-24" title="24">  displaySplash();</a>
<a class="sourceLine" id="cb27-25" title="25"></a>
<a class="sourceLine" id="cb27-26" title="26">  <span class="co">/* Make the ship object */</span></a>
<a class="sourceLine" id="cb27-27" title="27">  <span class="at">static</span> <span class="at">const</span> <span class="dt">int</span> SHUTTLE_OAM_ID = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb27-28" title="28">  SpriteEntry * shipEntry = &amp;oam-&gt;oamBuffer[SHUTTLE_OAM_ID];</a>
<a class="sourceLine" id="cb27-29" title="29">  SpriteRotation * shipRotation = &amp;oam-&gt;matrixBuffer[SHUTTLE_OAM_ID];</a>
<a class="sourceLine" id="cb27-30" title="30">  Ship * ship = <span class="kw">new</span> Ship(&amp;spriteInfo[SHUTTLE_OAM_ID]);</a>
<a class="sourceLine" id="cb27-31" title="31"></a>
<a class="sourceLine" id="cb27-32" title="32">  <span class="co">/* Accelerate the ship for a little while to make it move. */</span></a>
<a class="sourceLine" id="cb27-33" title="33">  <span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; <span class="dv">10</span>; i++) {</a>
<a class="sourceLine" id="cb27-34" title="34">    ship-&gt;accelerate();</a>
<a class="sourceLine" id="cb27-35" title="35">  }</a>
<a class="sourceLine" id="cb27-36" title="36"></a>
<a class="sourceLine" id="cb27-37" title="37">  <span class="co">/*</span></a>
<a class="sourceLine" id="cb27-38" title="38"><span class="co">   *  Update the OAM.</span></a>
<a class="sourceLine" id="cb27-39" title="39"><span class="co">   *</span></a>
<a class="sourceLine" id="cb27-40" title="40"><span class="co">   *  We have to copy our copy of OAM data into the actual</span></a>
<a class="sourceLine" id="cb27-41" title="41"><span class="co">   *  OAM during VBlank (writes to it are locked during</span></a>
<a class="sourceLine" id="cb27-42" title="42"><span class="co">   *  other times).</span></a>
<a class="sourceLine" id="cb27-43" title="43"><span class="co">   */</span></a>
<a class="sourceLine" id="cb27-44" title="44">  swiWaitForVBlank();</a>
<a class="sourceLine" id="cb27-45" title="45">  updateOAM(oam);</a>
<a class="sourceLine" id="cb27-46" title="46"></a>
<a class="sourceLine" id="cb27-47" title="47">  <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb27-48" title="48">}</a>
<a class="sourceLine" id="cb27-49" title="49">    </a></code></pre></div>
<h2>Creating the Main Game Loop</h2>
<p>The previous code isn't very exciting, since we never update the OAM more than once. We need to begin the creation of what is referred to as the game loop. We won't be fully implementing it in this chapter, since a major component of it will be missing until we discover input on the Nintendo DS.</p>
<p>The game loop has at least three major components. The first thing any game loop should do is to collect input from the outside world. We won't be doing that in this chapter, however. The next component of the game loop is updating the game state. Based on inputs the game received in the previous frame (to the one we'll render next) and the passing of time, the game state will change (if anything interesting is happening). The final component of the game loop is the rendering component. In our case, we have to update the OAM to let it know of the changes that occured in the game state and that it needs to reflect those changes.</p>
<p>Now that we know what a game loop is, it's time for us to start creating one to run our program. The first thing we want to happen in our game loop is for the game state to be updated. This is because we don't have any input to collect yet. We tell our ship to move at it's current velocity. This will change the ship’s position. Then we update the sprite attributes with new information about our ship, as some properties of the ship have now changed (i.e. its angle and position). Note that the rotateSprite function performs a counter-clockwise rotation and our ship tracks its angle as a clockwise rotation; this is resolved by simplying negating the angle to rotate by. Finally, we call a function that will make sure our program does not exceed 60fps (speed of the graphics on the Nintendo DS) by waiting for vblank, and then we update the OAM, telling it that we changed some attributes on the sprites and it needs to handle that.</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode C++"><code class="sourceCode cpp"><a class="sourceLine" id="cb28-1" title="1">  <span class="cf">for</span> (;;) {</a>
<a class="sourceLine" id="cb28-2" title="2">    <span class="co">/* Update the game state. */</span></a>
<a class="sourceLine" id="cb28-3" title="3">    ship-&gt;moveShip();</a>
<a class="sourceLine" id="cb28-4" title="4"></a>
<a class="sourceLine" id="cb28-5" title="5">    <span class="co">/* Update sprite attributes. */</span></a>
<a class="sourceLine" id="cb28-6" title="6">    MathVector2D&lt;<span class="dt">float</span>&gt; position = ship-&gt;getPosition();</a>
<a class="sourceLine" id="cb28-7" title="7">    shipEntry-&gt;x = (<span class="dt">int</span>)position.x;</a>
<a class="sourceLine" id="cb28-8" title="8">    shipEntry-&gt;y = (<span class="dt">int</span>)position.y;</a>
<a class="sourceLine" id="cb28-9" title="9">    rotateSprite(shipRotation, -ship-&gt;getAngleDeg());</a>
<a class="sourceLine" id="cb28-10" title="10"></a>
<a class="sourceLine" id="cb28-11" title="11">    <span class="co">/*</span></a>
<a class="sourceLine" id="cb28-12" title="12"><span class="co">     *  Update the OAM.</span></a>
<a class="sourceLine" id="cb28-13" title="13"><span class="co">     *</span></a>
<a class="sourceLine" id="cb28-14" title="14"><span class="co">     *  We have to copy our copy of OAM data into the actual OAM during</span></a>
<a class="sourceLine" id="cb28-15" title="15"><span class="co">     *  VBlank (writes to it are locked during other times).</span></a>
<a class="sourceLine" id="cb28-16" title="16"><span class="co">     */</span></a>
<a class="sourceLine" id="cb28-17" title="17">    swiWaitForVBlank();</a>
<a class="sourceLine" id="cb28-18" title="18">    updateOAM(oam);</a>
<a class="sourceLine" id="cb28-19" title="19">  }</a>
<a class="sourceLine" id="cb28-20" title="20"></a>
<a class="sourceLine" id="cb28-21" title="21">  <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb28-22" title="22">}</a>
<a class="sourceLine" id="cb28-23" title="23">      </a></code></pre></div>
<p>The OAM really shines through here. The all powerful Nintendo DS hardware, an incredible masterpiece, will rotate and move our ship with very little effort on our part. In hindsight, all we have done is flip a few bits in a few registers in a structured manner, and our ship comes to life. Incredible.</p>
<h2>Compiling</h2>
<p>Verify that you are including all the files you need to include now, before compiling.</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode C++"><code class="sourceCode cpp"><a class="sourceLine" id="cb29-1" title="1"><span class="pp">#include </span><span class="im">&lt;nds.h&gt;</span></a>
<a class="sourceLine" id="cb29-2" title="2"><span class="pp">#include </span><span class="im">&lt;assert.h&gt;</span></a>
<a class="sourceLine" id="cb29-3" title="3"><span class="pp">#include </span><span class="im">&quot;sprites.h&quot;</span></a>
<a class="sourceLine" id="cb29-4" title="4"><span class="pp">#include </span><span class="im">&quot;ship.h&quot;</span></a>
<a class="sourceLine" id="cb29-5" title="5"></a>
<a class="sourceLine" id="cb29-6" title="6"><span class="co">/* Backgrounds */</span></a>
<a class="sourceLine" id="cb29-7" title="7"><span class="pp">#include </span><span class="im">&quot;starField.h&quot;</span></a>
<a class="sourceLine" id="cb29-8" title="8"><span class="pp">#include </span><span class="im">&quot;planet.h&quot;</span></a>
<a class="sourceLine" id="cb29-9" title="9"><span class="pp">#include </span><span class="im">&quot;splash.h&quot;</span></a>
<a class="sourceLine" id="cb29-10" title="10"><span class="co">/* Sprites */</span></a>
<a class="sourceLine" id="cb29-11" title="11"><span class="pp">#include </span><span class="im">&quot;orangeShuttle.h&quot;</span></a>
<a class="sourceLine" id="cb29-12" title="12"><span class="pp">#include </span><span class="im">&quot;moon.h&quot;</span></a>
<a class="sourceLine" id="cb29-13" title="13">      </a></code></pre></div>
<p>Everything should compile for you fine at this point if you wish to play around with your new class. However, in the next chapter we will cover how to get Nintendo DS input to affect the Ship. Be ready for it, we're going to have some major fun.</p>
<p><img src="images/orange_shuttle.png" /></p>
<h1>Nintendo DS Input Systems</h1>
<h2>Overview</h2>
<p>The Nintendo DS has many different user input systems, including buttons, touch screen, and a microphone. Most video game systems only have buttons and an analog stick or two. While the Nintendo DS does not have an analog stick, it does have an amazing touch screen which has millions of different creative uses. We will only cover the touch screen and buttons, though. If you wish to learn more about the microphone, I'd recommend reading, although a bit outdated, the only microphone resource I know of <a href="http://www.double.co.nz/nintendo_ds/nds_develop9.html"></a>.</p>
<h2>Key Input</h2>
<p>libnds provides us with a very nice abstraction for key input. Instead of having to AND registers with cryptic masks to discover which keys we are pressing, we simply call <code class="sourceCode cpp">scanKeys</code>, then check one of three input functions, <code class="sourceCode cpp">keysDown()</code>, <code class="sourceCode cpp">keysHeld</code>, or <code class="sourceCode cpp">keysUp</code>. In order to see which keys have been recently pressed, use <code class="sourceCode cpp">keysDown</code>. To see which keys are currently held, use <code class="sourceCode cpp">keysHeld</code>. To see which keys have just been released, use <code class="sourceCode cpp">keysUp</code>. libnds provides us with defines for some key masks as well. How they are set up is explained in <a href="#libnds_key_defines">table_title</a>.</p>
<table>
<caption>libnds Key Defines</caption>
<thead>
<tr class="header">
<th>Key Define</th>
<th>Mask Bit</th>
<th>Associated Input</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>KEY_A</td>
<td>1 &lt;&lt; 0</td>
<td>A Button</td>
</tr>
<tr class="even">
<td>KEY_B</td>
<td>1 &lt;&lt; 1</td>
<td>B Button</td>
</tr>
<tr class="odd">
<td>KEY_SELECT</td>
<td>1 &lt;&lt; 2</td>
<td>Select Button</td>
</tr>
<tr class="even">
<td>KEY_START</td>
<td>1 &lt;&lt; 3</td>
<td>Start Button</td>
</tr>
<tr class="odd">
<td>KEY_RIGHT</td>
<td>1 &lt;&lt; 4</td>
<td>Right D-pad</td>
</tr>
<tr class="even">
<td>KEY_LEFT</td>
<td>1 &lt;&lt; 5</td>
<td>Left D-pad</td>
</tr>
<tr class="odd">
<td>KEY_UP</td>
<td>1 &lt;&lt; 6</td>
<td>Up D-pad</td>
</tr>
<tr class="even">
<td>KEY_DOWN</td>
<td>1 &lt;&lt; 7</td>
<td>Down D-pad</td>
</tr>
<tr class="odd">
<td>KEY_R</td>
<td>1 &lt;&lt; 8</td>
<td>R Button</td>
</tr>
<tr class="even">
<td>KEY_L</td>
<td>1 &lt;&lt; 9</td>
<td>L Button</td>
</tr>
<tr class="odd">
<td>KEY_X</td>
<td>1 &lt;&lt; 10</td>
<td>X Button</td>
</tr>
<tr class="even">
<td>KEY_Y</td>
<td>1 &lt;&lt; 11</td>
<td>Y Button</td>
</tr>
<tr class="odd">
<td>KEY_TOUCH</td>
<td>1 &lt;&lt; 12</td>
<td>Pen Touching Screen (no coordinates)</td>
</tr>
<tr class="even">
<td>KEY_LID</td>
<td>1 &lt;&lt; 13</td>
<td>Lid shutting (useful for sleeping)</td>
</tr>
</tbody>
</table>
<h2>Touch!</h2>
<p>Utada Hikaru (<a href="https://www.youtube.com/watch?v=bYoVeIGl0ao"></a>) wants to touch it. You have to code it. Let's go!</p>
<p>The touch screen a big part of what makes the Nintendo DS awesome. The libnds API for using it is cake easy too. We'll be ready for Utada Hikaru in no time. Whenever you want to read the current touch location, simply call the function <code class="sourceCode cpp">touchRead</code>. This function assigns values to a struct that contains the x and y coordinate of the touch. You use it like so.</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode C++"><code class="sourceCode cpp"><a class="sourceLine" id="cb30-1" title="1"><span class="co">/* To read from the touch screen, we can do this stuff. */</span></a>
<a class="sourceLine" id="cb30-2" title="2">touchPosition touch;</a>
<a class="sourceLine" id="cb30-3" title="3">touchRead(&amp;touch);</a>
<a class="sourceLine" id="cb30-4" title="4">touch-&gt;px; <span class="co">// This contains the x pixel location.</span></a>
<a class="sourceLine" id="cb30-5" title="5">touch-&gt;py; <span class="co">// This contains the y pixel location.</span></a>
<a class="sourceLine" id="cb30-6" title="6">      </a></code></pre></div>
<blockquote>
<p><strong>Note</strong></p>
<p>You may see code that uses something called the IPC to interact with the touch screen. Use of the IPC struct is deprecated. This means that you shouldn't use it and should not depend on it being there in the future. The method we use to read values from the touch screen does not use the IPC struct and is safe for future use.</p>
</blockquote>
<h2>Writing an Input Updating Function</h2>
<p>Now that we know a bit about how input is laid out on the Nintendo DS, let's write a function in our <code>main.cpp</code> to collect the input for us. We'll call it <code class="sourceCode cpp">updateInput</code>. We'll use this function as the first thing we call in our complete game loop.</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode C++"><code class="sourceCode cpp"><a class="sourceLine" id="cb31-1" title="1"><span class="dt">void</span> updateInput(touchPosition * touch) {</a>
<a class="sourceLine" id="cb31-2" title="2">  <span class="co">// Update the key registers with current values.</span></a>
<a class="sourceLine" id="cb31-3" title="3">  scanKeys();</a>
<a class="sourceLine" id="cb31-4" title="4"></a>
<a class="sourceLine" id="cb31-5" title="5">  <span class="co">// Update the touch screen values.</span></a>
<a class="sourceLine" id="cb31-6" title="6">  touchRead(touch);</a>
<a class="sourceLine" id="cb31-7" title="7">}</a>
<a class="sourceLine" id="cb31-8" title="8">      </a></code></pre></div>
<h2>Writing an Input Handling Function</h2>
<p>This function will be part of our game state updating game loop component. It will react to outside input and modify the game state accordingly. As such, it will have to know about and be able to modify the game state. We'll pass the game state to it as function parameters. Let's call the function <code class="sourceCode cpp">handleInput</code>.</p>
<p>First, we want the ship to accelerate when we press up. To do this, we detect when the Nintendo DS has the up key on the D-pad held (which included the initial down press) and accelerate the ship if so. The up key will constantly read as held, so long as it is held. Reading the input does not affect the keys register. We'll do similar things for each of the other keys. See if you can tell what each key does from the code listing below.</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode C++"><code class="sourceCode cpp"><a class="sourceLine" id="cb32-1" title="1"><span class="dt">void</span> handleInput(Ship * ship, MathVector2D&lt;<span class="dt">int</span>&gt; * moonPos,</a>
<a class="sourceLine" id="cb32-2" title="2">         SpriteInfo * moonInfo, touchPosition * touch) {</a>
<a class="sourceLine" id="cb32-3" title="3"></a>
<a class="sourceLine" id="cb32-4" title="4">  <span class="co">/* Handle up and down parts of D-Pad. */</span></a>
<a class="sourceLine" id="cb32-5" title="5">  <span class="cf">if</span> (keysHeld() &amp; KEY_UP) {</a>
<a class="sourceLine" id="cb32-6" title="6">    <span class="co">//accelerate ship</span></a>
<a class="sourceLine" id="cb32-7" title="7">    ship-&gt;accelerate();</a>
<a class="sourceLine" id="cb32-8" title="8">  } <span class="cf">else</span> <span class="cf">if</span> (keysHeld() &amp; KEY_DOWN) {</a>
<a class="sourceLine" id="cb32-9" title="9">    <span class="co">//reverse ship direction</span></a>
<a class="sourceLine" id="cb32-10" title="10">    ship-&gt;reverseTurn();</a>
<a class="sourceLine" id="cb32-11" title="11">  }</a>
<a class="sourceLine" id="cb32-12" title="12"></a>
<a class="sourceLine" id="cb32-13" title="13">  <span class="co">/* Handle left and right parts of D-Pad. */</span></a>
<a class="sourceLine" id="cb32-14" title="14">  <span class="cf">if</span> (keysHeld() &amp; KEY_LEFT) {</a>
<a class="sourceLine" id="cb32-15" title="15">    <span class="co">//rotate counter clockwise</span></a>
<a class="sourceLine" id="cb32-16" title="16">    ship-&gt;turnCounterClockwise();</a>
<a class="sourceLine" id="cb32-17" title="17">  } <span class="cf">else</span> <span class="cf">if</span> (keysHeld() &amp; KEY_RIGHT) {</a>
<a class="sourceLine" id="cb32-18" title="18">    <span class="co">//rotate clockwise</span></a>
<a class="sourceLine" id="cb32-19" title="19">    ship-&gt;turnClockwise();</a>
<a class="sourceLine" id="cb32-20" title="20">  }</a>
<a class="sourceLine" id="cb32-21" title="21"></a>
<a class="sourceLine" id="cb32-22" title="22">  <span class="co">/*</span></a>
<a class="sourceLine" id="cb32-23" title="23"><span class="co">   *  Handle the touch screen.</span></a>
<a class="sourceLine" id="cb32-24" title="24"><span class="co">   *</span></a>
<a class="sourceLine" id="cb32-25" title="25"><span class="co">   *  This is basically some fancy pants junk to enable grabbing and moving</span></a>
<a class="sourceLine" id="cb32-26" title="26"><span class="co">   *  of the moon. It isn&#39;t essential to know how this code works to</span></a>
<a class="sourceLine" id="cb32-27" title="27"><span class="co">   *  understand how to reach values from the touch screen, but it was cool</span></a>
<a class="sourceLine" id="cb32-28" title="28"><span class="co">   *  enough that I wanted to put it in the case study.</span></a>
<a class="sourceLine" id="cb32-29" title="29"><span class="co">  */</span></a>
<a class="sourceLine" id="cb32-30" title="30">  <span class="at">static</span> MathVector2D&lt;<span class="dt">int</span>&gt; moonGrip;</a>
<a class="sourceLine" id="cb32-31" title="31">  <span class="cf">if</span> (keysDown() &amp; KEY_TOUCH) {</a>
<a class="sourceLine" id="cb32-32" title="32">    <span class="co">/* Record the grip */</span></a>
<a class="sourceLine" id="cb32-33" title="33">    moonGrip.x = touch-&gt;px;</a>
<a class="sourceLine" id="cb32-34" title="34">    moonGrip.y = touch-&gt;py;</a>
<a class="sourceLine" id="cb32-35" title="35">  } <span class="cf">else</span> <span class="cf">if</span> (keysHeld() &amp; KEY_TOUCH) {</a>
<a class="sourceLine" id="cb32-36" title="36">    <span class="dt">int</span> newX = moonPos-&gt;x + touch-&gt;px - moonGrip.x;</a>
<a class="sourceLine" id="cb32-37" title="37">    <span class="dt">int</span> newY = moonPos-&gt;y + touch-&gt;py - moonGrip.y;</a>
<a class="sourceLine" id="cb32-38" title="38"></a>
<a class="sourceLine" id="cb32-39" title="39">    <span class="co">/* Prevent dragging off the screen */</span></a>
<a class="sourceLine" id="cb32-40" title="40">    <span class="cf">if</span> (newX &lt; <span class="dv">0</span>) {</a>
<a class="sourceLine" id="cb32-41" title="41">      moonPos-&gt;x = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb32-42" title="42">    } <span class="cf">else</span> <span class="cf">if</span> (newX &gt; (SCREEN_WIDTH - moonInfo-&gt;width)) {</a>
<a class="sourceLine" id="cb32-43" title="43">      moonPos-&gt;x = SCREEN_WIDTH - moonInfo-&gt;width;</a>
<a class="sourceLine" id="cb32-44" title="44">    } <span class="cf">else</span> {</a>
<a class="sourceLine" id="cb32-45" title="45">      moonPos-&gt;x = newX;</a>
<a class="sourceLine" id="cb32-46" title="46">    }</a>
<a class="sourceLine" id="cb32-47" title="47">    <span class="cf">if</span> (newY &lt; <span class="dv">0</span>) {</a>
<a class="sourceLine" id="cb32-48" title="48">      moonPos-&gt;y = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb32-49" title="49">    } <span class="cf">else</span> <span class="cf">if</span> (newY &gt; (SCREEN_HEIGHT - moonInfo-&gt;height)) {</a>
<a class="sourceLine" id="cb32-50" title="50">      moonPos-&gt;y = SCREEN_HEIGHT - moonInfo-&gt;height;</a>
<a class="sourceLine" id="cb32-51" title="51">    } <span class="cf">else</span> {</a>
<a class="sourceLine" id="cb32-52" title="52">      moonPos-&gt;y = newY;</a>
<a class="sourceLine" id="cb32-53" title="53">    }</a>
<a class="sourceLine" id="cb32-54" title="54"></a>
<a class="sourceLine" id="cb32-55" title="55">    <span class="co">/* Record the grip again. */</span></a>
<a class="sourceLine" id="cb32-56" title="56">    moonGrip.x = touch-&gt;px;</a>
<a class="sourceLine" id="cb32-57" title="57">    moonGrip.y = touch-&gt;py;</a>
<a class="sourceLine" id="cb32-58" title="58">  }</a>
<a class="sourceLine" id="cb32-59" title="59">}</a>
<a class="sourceLine" id="cb32-60" title="60">      </a></code></pre></div>
<p>As you've noticed, having that Ship class made input handling extremely easy. Our keys will directly affect various properties of the ship as we press them. This is really amazing, but the true miracle is yet to come.</p>
<p>As for the moon, since we didn't make one class for it, the code came together a little more messily. We also had to pass two parameters to the <code class="sourceCode cpp">handleInput</code> function to represent the moon portion of the game state instead of one. If we had wanted to be more clean, we could have even produced a game state struct that contained all the game state and all operations on it in one place.</p>
<h2>Creating the Main Game Loop, Again</h2>
<p>Let's check back in on our <code class="sourceCode cpp">main</code> function now. We need to make some adjustments to our game loop since we've now added the ability to collect input and to react to input. The first thing we now want to happen in our game loop is for the key registers and read touch screen coordinates to get updated. We make a call to updateInput and it all happens for us. Next, we handle the input we just received by calling our recently created <code class="sourceCode cpp">handleInput</code> function, passing in our game state so that it can change it for us. Everything else is as before.</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode C++"><code class="sourceCode cpp"><a class="sourceLine" id="cb33-1" title="1"><span class="dt">int</span> main() {</a>
<a class="sourceLine" id="cb33-2" title="2">  <span class="co">/*  Turn on the 2D graphics core. */</span></a>
<a class="sourceLine" id="cb33-3" title="3">  powerOn(POWER_ALL_2D);</a>
<a class="sourceLine" id="cb33-4" title="4"></a>
<a class="sourceLine" id="cb33-5" title="5">  <span class="co">/*</span></a>
<a class="sourceLine" id="cb33-6" title="6"><span class="co">   *  Configure the VRAM and background control registers.</span></a>
<a class="sourceLine" id="cb33-7" title="7"><span class="co">   *</span></a>
<a class="sourceLine" id="cb33-8" title="8"><span class="co">   *  Place the main screen on the bottom physical screen. Then arrange the</span></a>
<a class="sourceLine" id="cb33-9" title="9"><span class="co">   *  VRAM banks. Next, confiure the background control registers.</span></a>
<a class="sourceLine" id="cb33-10" title="10"><span class="co">   */</span></a>
<a class="sourceLine" id="cb33-11" title="11">  lcdMainOnBottom();</a>
<a class="sourceLine" id="cb33-12" title="12">  initVideo();</a>
<a class="sourceLine" id="cb33-13" title="13">  initBackgrounds();</a>
<a class="sourceLine" id="cb33-14" title="14"></a>
<a class="sourceLine" id="cb33-15" title="15">  <span class="co">/* Set up a few sprites. */</span></a>
<a class="sourceLine" id="cb33-16" title="16">  SpriteInfo spriteInfo[SPRITE_COUNT];</a>
<a class="sourceLine" id="cb33-17" title="17">  OAMTable *oam = <span class="kw">new</span> OAMTable();</a>
<a class="sourceLine" id="cb33-18" title="18">  iniOAMTable(oam);</a>
<a class="sourceLine" id="cb33-19" title="19">  initSprites(oam, spriteInfo);</a>
<a class="sourceLine" id="cb33-20" title="20"></a>
<a class="sourceLine" id="cb33-21" title="21">  <span class="co">/* Display the backgrounds. */</span></a>
<a class="sourceLine" id="cb33-22" title="22">  displayStarField();</a>
<a class="sourceLine" id="cb33-23" title="23">  displayPlanet();</a>
<a class="sourceLine" id="cb33-24" title="24">  displaySplash();</a>
<a class="sourceLine" id="cb33-25" title="25"></a>
<a class="sourceLine" id="cb33-26" title="26">  <span class="co">/*************************************************************************/</span></a>
<a class="sourceLine" id="cb33-27" title="27"></a>
<a class="sourceLine" id="cb33-28" title="28">  <span class="co">/* Keep track of the touch screen coordinates */</span></a>
<a class="sourceLine" id="cb33-29" title="29">  touchPosition touch;</a>
<a class="sourceLine" id="cb33-30" title="30"></a>
<a class="sourceLine" id="cb33-31" title="31">  <span class="co">/* Make the ship object */</span></a>
<a class="sourceLine" id="cb33-32" title="32">  <span class="at">static</span> <span class="at">const</span> <span class="dt">int</span> SHUTTLE_AFFINE_ID = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb33-33" title="33">  SpriteEntry * shipEntry = &amp;oam-&gt;oamBuffer[SHUTTLE_AFFINE_ID];</a>
<a class="sourceLine" id="cb33-34" title="34">  SpriteRotation * shipRotation = &amp;oam-&gt;matrixBuffer[SHUTTLE_AFFINE_ID];</a>
<a class="sourceLine" id="cb33-35" title="35">  Ship * ship = <span class="kw">new</span> Ship(&amp;spriteInfo[SHUTTLE_AFFINE_ID]);</a>
<a class="sourceLine" id="cb33-36" title="36"></a>
<a class="sourceLine" id="cb33-37" title="37">  <span class="co">/* Make the moon */</span></a>
<a class="sourceLine" id="cb33-38" title="38">  <span class="at">static</span> <span class="at">const</span> <span class="dt">int</span> MOON_AFFINE_ID = <span class="dv">1</span>;</a>
<a class="sourceLine" id="cb33-39" title="39">  SpriteEntry * moonEntry = &amp;oam-&gt;oamBuffer[MOON_AFFINE_ID];</a>
<a class="sourceLine" id="cb33-40" title="40">  SpriteInfo * moonInfo = &amp;spriteInfo[MOON_AFFINE_ID];</a>
<a class="sourceLine" id="cb33-41" title="41">  MathVector2D&lt;<span class="dt">int</span>&gt; * moonPos = <span class="kw">new</span> MathVector2D&lt;<span class="dt">int</span>&gt;();</a>
<a class="sourceLine" id="cb33-42" title="42">  moonPos-&gt;x = moonEntry-&gt;x;</a>
<a class="sourceLine" id="cb33-43" title="43">  moonPos-&gt;y = moonEntry-&gt;y;</a>
<a class="sourceLine" id="cb33-44" title="44"></a>
<a class="sourceLine" id="cb33-45" title="45">  <span class="cf">for</span> (;;) {</a>
<a class="sourceLine" id="cb33-46" title="46">    <span class="co">/* Update the game state. */</span></a>
<a class="sourceLine" id="cb33-47" title="47">    updateInput(&amp;touch);</a>
<a class="sourceLine" id="cb33-48" title="48">    handleInput(ship, moonPos, moonInfo, &amp;touch);</a>
<a class="sourceLine" id="cb33-49" title="49">    ship-&gt;moveShip();</a>
<a class="sourceLine" id="cb33-50" title="50"></a>
<a class="sourceLine" id="cb33-51" title="51">    <span class="co">/* Update ship sprite attributes. */</span></a>
<a class="sourceLine" id="cb33-52" title="52">    MathVector2D&lt;<span class="dt">float</span>&gt; position = ship-&gt;getPosition();</a>
<a class="sourceLine" id="cb33-53" title="53">    shipEntry-&gt;x = (<span class="dt">int</span>)position.x;</a>
<a class="sourceLine" id="cb33-54" title="54">    shipEntry-&gt;y = (<span class="dt">int</span>)position.y;</a>
<a class="sourceLine" id="cb33-55" title="55">    rotateSprite(shipRotation, -ship-&gt;getAngleDeg());</a>
<a class="sourceLine" id="cb33-56" title="56">    <span class="co">/* Update moon sprite attributes. */</span></a>
<a class="sourceLine" id="cb33-57" title="57">    moonEntry-&gt;x = (<span class="dt">int</span>)moonPos-&gt;x;</a>
<a class="sourceLine" id="cb33-58" title="58">    moonEntry-&gt;y = (<span class="dt">int</span>)moonPos-&gt;y;</a>
<a class="sourceLine" id="cb33-59" title="59"></a>
<a class="sourceLine" id="cb33-60" title="60">    <span class="co">/*</span></a>
<a class="sourceLine" id="cb33-61" title="61"><span class="co">     *  Update the OAM.</span></a>
<a class="sourceLine" id="cb33-62" title="62"><span class="co">     *</span></a>
<a class="sourceLine" id="cb33-63" title="63"><span class="co">     *  We have to copy our copy of OAM data into the actual OAM during</span></a>
<a class="sourceLine" id="cb33-64" title="64"><span class="co">     *  VBlank (writes to it are locked during other times).</span></a>
<a class="sourceLine" id="cb33-65" title="65"><span class="co">     */</span></a>
<a class="sourceLine" id="cb33-66" title="66">    swiWaitForVBlank();</a>
<a class="sourceLine" id="cb33-67" title="67">    updateOAM(oam);</a>
<a class="sourceLine" id="cb33-68" title="68">  }</a>
<a class="sourceLine" id="cb33-69" title="69"></a>
<a class="sourceLine" id="cb33-70" title="70">  <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb33-71" title="71">}</a>
<a class="sourceLine" id="cb33-72" title="72">      </a></code></pre></div>
<h2>Compiling</h2>
<p>Again, we should double check that we have all the proper includes before compiling.</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode C++"><code class="sourceCode cpp"><a class="sourceLine" id="cb34-1" title="1"><span class="pp">#include </span><span class="im">&lt;nds.h&gt;</span></a>
<a class="sourceLine" id="cb34-2" title="2"><span class="pp">#include </span><span class="im">&lt;assert.h&gt;</span></a>
<a class="sourceLine" id="cb34-3" title="3"><span class="pp">#include </span><span class="im">&quot;sprites.h&quot;</span></a>
<a class="sourceLine" id="cb34-4" title="4"><span class="pp">#include </span><span class="im">&quot;ship.h&quot;</span></a>
<a class="sourceLine" id="cb34-5" title="5"></a>
<a class="sourceLine" id="cb34-6" title="6"><span class="co">/* Backgrounds */</span></a>
<a class="sourceLine" id="cb34-7" title="7"><span class="pp">#include </span><span class="im">&quot;starField.h&quot;</span></a>
<a class="sourceLine" id="cb34-8" title="8"><span class="pp">#include </span><span class="im">&quot;planet.h&quot;</span></a>
<a class="sourceLine" id="cb34-9" title="9"><span class="pp">#include </span><span class="im">&quot;splash.h&quot;</span></a>
<a class="sourceLine" id="cb34-10" title="10"><span class="co">/* Sprites */</span></a>
<a class="sourceLine" id="cb34-11" title="11"><span class="pp">#include </span><span class="im">&quot;orangeShuttle.h&quot;</span></a>
<a class="sourceLine" id="cb34-12" title="12"><span class="pp">#include </span><span class="im">&quot;moon.h&quot;</span></a>
<a class="sourceLine" id="cb34-13" title="13">      </a></code></pre></div>
<p>Now we can control our ship with the D-Pad. What fun! The game should now appear as in <a href="#chapter_8_screen_shot">figure_title</a>. Now if only we had some aliens to kill…</p>
<figure>
<img src="images/splash.png" alt="Flying around in the Orange Shuttle." /><figcaption>Flying around in the Orange Shuttle.</figcaption>
</figure>
<figure>
<img src="images/starfield_with_moving_orange_shuttle.png" alt="Flying around in the Orange Shuttle." /><figcaption>Flying around in the Orange Shuttle.</figcaption>
</figure>
<h1>What about the sounds?</h1>
<h2>A Sound Theory</h2>
<p>Sounds are essential in any game. Our little project should be no exception. Sounds bring life to various elements in the game, such as space ships, weapon systems, rain, sword clashing, car engines, and so forth.</p>
<p>Many games don't need music. For instance, a game with the programmer's or game designer's favorite song may annoy many players who have different tastes in music. Instead, give the player the option to listen to their own music, on their own audio equipment. Not to mention, music can be costly in data size.</p>
<p>Sound effects on the other hand, are quite useful. A word of warning, however, a game with bad sounds (scratchy, annoying, too repetitive, etc.) is worse than a silent game. Take care when engineering sounds for your game.</p>
<h2>The Hardware</h2>
<p>The Nintendo DS has amazing sound hardware. We will only be able to scratch the surface of it, and even still, we won't leave any scratch marks. The Nintendo DS has 16 channels to play sounds, numbered 0 through 15. Channels 8-15 are special channels. All channels can play ADPCM or PCM sounds, while 8-13 are the only channels that can play PSG sounds and 14-15 the only that can generate noise. We will only be experimenting with PCM sounds.</p>
<h2>Making the Sounds</h2>
<p>To play our sounds, we will use the unbelievebly impressive homebrew audtio library, maxmod. maxmod is distributed with libnds, so you should already have it installed. maxmod can play music as well as sound effects, in such formats as mod, it, s3m, xm, and wav, but we'll just be using it as a wav player to play our sound effects. For more information and deeper coverage of the library, visit <a href="http://maxmod.org/"></a>.</p>
<h2>Using the Sounds</h2>
<p>The makefile I've included with my manual has a custom rule for creating a <code>soundbank.bin</code> file from all audio files in the <code>audio</code> project folder. The rule runs mmutil to create the <code>soundbank.bin</code> and <code>soundbank.h</code> files. The bin2o rule turns the .bin file into something safe to link into your nds file and creates the <code>soundbank_bin.h</code> file. All of these header files will be located in the <code>build</code> folder after a build, if you wish to review their contents.</p>
<h2>Getting Down with the Code</h2>
<p>Now it's finally time for some code. maxmod simplifies sound playing quite a bit. All we need to do is initialize the library, let it know where our soundbank is, load the sound from our soundbank, and call a function to play the sound. It will serve our purposes for now, as a springboard into more advanced forms of sound. Enough with the chatter, here's some code for our <code>main.cpp</code>.</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode C++"><code class="sourceCode cpp"><a class="sourceLine" id="cb35-1" title="1"><span class="dt">void</span> handleInput(Ship * ship,</a>
<a class="sourceLine" id="cb35-2" title="2">         MathVector2D&lt;<span class="dt">int</span>&gt; * moonPos,</a>
<a class="sourceLine" id="cb35-3" title="3">         SpriteInfo * moonInfo,</a>
<a class="sourceLine" id="cb35-4" title="4">         touchPosition * touch) {</a>
<a class="sourceLine" id="cb35-5" title="5"></a>
<a class="sourceLine" id="cb35-6" title="6">  <span class="co">/* Handle up and down parts of D-Pad. */</span></a>
<a class="sourceLine" id="cb35-7" title="7">  <span class="cf">if</span> (keysDown() &amp; KEY_UP) {</a>
<a class="sourceLine" id="cb35-8" title="8">    <span class="co">// Play our sound only when the button is initially pressed</span></a>
<a class="sourceLine" id="cb35-9" title="9">    mmEffect(SFX_THRUST);</a>
<a class="sourceLine" id="cb35-10" title="10">  }</a>
<a class="sourceLine" id="cb35-11" title="11">  <span class="cf">if</span> (keysHeld() &amp; KEY_UP) {</a>
<a class="sourceLine" id="cb35-12" title="12">    <span class="co">//accelerate ship</span></a>
<a class="sourceLine" id="cb35-13" title="13">    ship-&gt;accelerate();</a>
<a class="sourceLine" id="cb35-14" title="14">  } <span class="cf">else</span> <span class="cf">if</span> (keysHeld() &amp; KEY_DOWN) {</a>
<a class="sourceLine" id="cb35-15" title="15">    <span class="co">//reverse ship direction</span></a>
<a class="sourceLine" id="cb35-16" title="16">    ship-&gt;reverseTurn();</a>
<a class="sourceLine" id="cb35-17" title="17">  }</a>
<a class="sourceLine" id="cb35-18" title="18"></a>
<a class="sourceLine" id="cb35-19" title="19">  <span class="co">/* Handle left and right parts of D-Pad. */</span></a>
<a class="sourceLine" id="cb35-20" title="20">  <span class="cf">if</span> (keysHeld() &amp; KEY_LEFT) {</a>
<a class="sourceLine" id="cb35-21" title="21">    <span class="co">//rotate counter clockwise</span></a>
<a class="sourceLine" id="cb35-22" title="22">    ship-&gt;turnCounterClockwise();</a>
<a class="sourceLine" id="cb35-23" title="23">  } <span class="cf">else</span> <span class="cf">if</span> (keysHeld() &amp; KEY_RIGHT) {</a>
<a class="sourceLine" id="cb35-24" title="24">    <span class="co">//rotate clockwise</span></a>
<a class="sourceLine" id="cb35-25" title="25">    ship-&gt;turnClockwise();</a>
<a class="sourceLine" id="cb35-26" title="26">  }</a>
<a class="sourceLine" id="cb35-27" title="27"></a>
<a class="sourceLine" id="cb35-28" title="28">  <span class="co">/* Handle the touch screen. */</span></a>
<a class="sourceLine" id="cb35-29" title="29">  <span class="at">static</span> MathVector2D&lt;<span class="dt">int</span>&gt; moonGrip;</a>
<a class="sourceLine" id="cb35-30" title="30">  <span class="cf">if</span> (keysDown() &amp; KEY_TOUCH) {</a>
<a class="sourceLine" id="cb35-31" title="31">    <span class="co">/* Record the grip */</span></a>
<a class="sourceLine" id="cb35-32" title="32">    moonGrip.x = touch-&gt;px;</a>
<a class="sourceLine" id="cb35-33" title="33">    moonGrip.y = touch-&gt;py;</a>
<a class="sourceLine" id="cb35-34" title="34">  } <span class="cf">else</span> <span class="cf">if</span> (keysHeld() &amp; KEY_TOUCH) {</a>
<a class="sourceLine" id="cb35-35" title="35">    <span class="dt">int</span> newX = moonPos-&gt;x + touch-&gt;px - moonGrip.x;</a>
<a class="sourceLine" id="cb35-36" title="36">    <span class="dt">int</span> newY = moonPos-&gt;y + touch-&gt;py - moonGrip.y;</a>
<a class="sourceLine" id="cb35-37" title="37"></a>
<a class="sourceLine" id="cb35-38" title="38">    <span class="co">/* Prevent dragging off the screen */</span></a>
<a class="sourceLine" id="cb35-39" title="39">    <span class="cf">if</span> (newX &lt; <span class="dv">0</span>) {</a>
<a class="sourceLine" id="cb35-40" title="40">      moonPos-&gt;x = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb35-41" title="41">    } <span class="cf">else</span> <span class="cf">if</span> (newX &gt; (SCREEN_WIDTH - moonInfo-&gt;width)) {</a>
<a class="sourceLine" id="cb35-42" title="42">      moonPos-&gt;x = SCREEN_WIDTH - moonInfo-&gt;width;</a>
<a class="sourceLine" id="cb35-43" title="43">    } <span class="cf">else</span> {</a>
<a class="sourceLine" id="cb35-44" title="44">      moonPos-&gt;x = newX;</a>
<a class="sourceLine" id="cb35-45" title="45">    }</a>
<a class="sourceLine" id="cb35-46" title="46">    <span class="cf">if</span> (newY &lt; <span class="dv">0</span>) {</a>
<a class="sourceLine" id="cb35-47" title="47">      moonPos-&gt;y = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb35-48" title="48">    } <span class="cf">else</span> <span class="cf">if</span> (newY &gt; (SCREEN_HEIGHT - moonInfo-&gt;height)) {</a>
<a class="sourceLine" id="cb35-49" title="49">      moonPos-&gt;y = SCREEN_HEIGHT - moonInfo-&gt;height;</a>
<a class="sourceLine" id="cb35-50" title="50">    } <span class="cf">else</span> {</a>
<a class="sourceLine" id="cb35-51" title="51">      moonPos-&gt;y = newY;</a>
<a class="sourceLine" id="cb35-52" title="52">    }</a>
<a class="sourceLine" id="cb35-53" title="53"></a>
<a class="sourceLine" id="cb35-54" title="54">    <span class="co">/* Record the grip again. */</span></a>
<a class="sourceLine" id="cb35-55" title="55">    moonGrip.x = touch-&gt;px;</a>
<a class="sourceLine" id="cb35-56" title="56">    moonGrip.y = touch-&gt;py;</a>
<a class="sourceLine" id="cb35-57" title="57">  }</a>
<a class="sourceLine" id="cb35-58" title="58">}</a>
<a class="sourceLine" id="cb35-59" title="59"></a>
<a class="sourceLine" id="cb35-60" title="60"><span class="dt">int</span> main() {</a>
<a class="sourceLine" id="cb35-61" title="61">  <span class="co">/*  Turn on the 2D graphics core. */</span></a>
<a class="sourceLine" id="cb35-62" title="62">  powerOn(POWER_ALL_2D);</a>
<a class="sourceLine" id="cb35-63" title="63"></a>
<a class="sourceLine" id="cb35-64" title="64">  <span class="co">/*</span></a>
<a class="sourceLine" id="cb35-65" title="65"><span class="co">   *  Configure the VRAM and background control registers.</span></a>
<a class="sourceLine" id="cb35-66" title="66"><span class="co">   *</span></a>
<a class="sourceLine" id="cb35-67" title="67"><span class="co">   *  Place the main screen on the bottom physical screen. Then arrange the</span></a>
<a class="sourceLine" id="cb35-68" title="68"><span class="co">   *  VRAM banks. Next, confiure the background control registers.</span></a>
<a class="sourceLine" id="cb35-69" title="69"><span class="co">   */</span></a>
<a class="sourceLine" id="cb35-70" title="70">  lcdMainOnBottom();</a>
<a class="sourceLine" id="cb35-71" title="71">  initVideo();</a>
<a class="sourceLine" id="cb35-72" title="72">  initBackgrounds();</a>
<a class="sourceLine" id="cb35-73" title="73"></a>
<a class="sourceLine" id="cb35-74" title="74">  <span class="co">/* Initialize maxmod using the memory based soundbank set up. */</span></a>
<a class="sourceLine" id="cb35-75" title="75">  mmInitDefaultMem((mm_addr)soundbank_bin);</a>
<a class="sourceLine" id="cb35-76" title="76"></a>
<a class="sourceLine" id="cb35-77" title="77">  <span class="co">/* Set up a few sprites. */</span></a>
<a class="sourceLine" id="cb35-78" title="78">  SpriteInfo spriteInfo[SPRITE_COUNT];</a>
<a class="sourceLine" id="cb35-79" title="79">  OAMTable *oam = <span class="kw">new</span> OAMTable();</a>
<a class="sourceLine" id="cb35-80" title="80">  iniOAMTable(oam);</a>
<a class="sourceLine" id="cb35-81" title="81">  initSprites(oam, spriteInfo);</a>
<a class="sourceLine" id="cb35-82" title="82"></a>
<a class="sourceLine" id="cb35-83" title="83">  <span class="co">/* Display the backgrounds. */</span></a>
<a class="sourceLine" id="cb35-84" title="84">  displayStarField();</a>
<a class="sourceLine" id="cb35-85" title="85">  displayPlanet();</a>
<a class="sourceLine" id="cb35-86" title="86">  displaySplash();</a>
<a class="sourceLine" id="cb35-87" title="87"></a>
<a class="sourceLine" id="cb35-88" title="88">  <span class="co">/*************************************************************************/</span></a>
<a class="sourceLine" id="cb35-89" title="89"></a>
<a class="sourceLine" id="cb35-90" title="90">  <span class="co">/* Keep track of the touch screen coordinates */</span></a>
<a class="sourceLine" id="cb35-91" title="91">  touchPosition touch;</a>
<a class="sourceLine" id="cb35-92" title="92"></a>
<a class="sourceLine" id="cb35-93" title="93">  <span class="co">/* Make the ship object */</span></a>
<a class="sourceLine" id="cb35-94" title="94">  <span class="at">static</span> <span class="at">const</span> <span class="dt">int</span> SHUTTLE_AFFINE_ID = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb35-95" title="95">  SpriteEntry * shipEntry = &amp;oam-&gt;oamBuffer[SHUTTLE_AFFINE_ID];</a>
<a class="sourceLine" id="cb35-96" title="96">  SpriteRotation * shipRotation = &amp;oam-&gt;matrixBuffer[SHUTTLE_AFFINE_ID];</a>
<a class="sourceLine" id="cb35-97" title="97">  Ship * ship = <span class="kw">new</span> Ship(&amp;spriteInfo[SHUTTLE_AFFINE_ID]);</a>
<a class="sourceLine" id="cb35-98" title="98"></a>
<a class="sourceLine" id="cb35-99" title="99">  <span class="co">/* Make the moon */</span></a>
<a class="sourceLine" id="cb35-100" title="100">  <span class="at">static</span> <span class="at">const</span> <span class="dt">int</span> MOON_AFFINE_ID = <span class="dv">1</span>;</a>
<a class="sourceLine" id="cb35-101" title="101">  SpriteEntry * moonEntry = &amp;oam-&gt;oamBuffer[MOON_AFFINE_ID];</a>
<a class="sourceLine" id="cb35-102" title="102">  SpriteInfo * moonInfo = &amp;spriteInfo[MOON_AFFINE_ID];</a>
<a class="sourceLine" id="cb35-103" title="103">  MathVector2D&lt;<span class="dt">int</span>&gt; * moonPos = <span class="kw">new</span> MathVector2D&lt;<span class="dt">int</span>&gt;();</a>
<a class="sourceLine" id="cb35-104" title="104">  moonPos-&gt;x = moonEntry-&gt;x;</a>
<a class="sourceLine" id="cb35-105" title="105">  moonPos-&gt;y = moonEntry-&gt;y;</a>
<a class="sourceLine" id="cb35-106" title="106"></a>
<a class="sourceLine" id="cb35-107" title="107">  <span class="co">/*  Set up sound data.*/</span></a>
<a class="sourceLine" id="cb35-108" title="108">  mmLoadEffect(SFX_THRUST);</a>
<a class="sourceLine" id="cb35-109" title="109"></a>
<a class="sourceLine" id="cb35-110" title="110">  <span class="cf">for</span> (;;) {</a>
<a class="sourceLine" id="cb35-111" title="111">    <span class="co">/* Update the game state. */</span></a>
<a class="sourceLine" id="cb35-112" title="112">    updateInput(&amp;touch);</a>
<a class="sourceLine" id="cb35-113" title="113">    handleInput(ship, moonPos, moonInfo,&amp;touch);</a>
<a class="sourceLine" id="cb35-114" title="114">    ship-&gt;moveShip();</a>
<a class="sourceLine" id="cb35-115" title="115"></a>
<a class="sourceLine" id="cb35-116" title="116">    <span class="co">/* Update ship sprite attributes. */</span></a>
<a class="sourceLine" id="cb35-117" title="117">    MathVector2D&lt;<span class="dt">float</span>&gt; position = ship-&gt;getPosition();</a>
<a class="sourceLine" id="cb35-118" title="118">    shipEntry-&gt;x = (<span class="dt">int</span>)position.x;</a>
<a class="sourceLine" id="cb35-119" title="119">    shipEntry-&gt;y = (<span class="dt">int</span>)position.y;</a>
<a class="sourceLine" id="cb35-120" title="120">    rotateSprite(shipRotation, -ship-&gt;getAngleDeg());</a>
<a class="sourceLine" id="cb35-121" title="121">    <span class="co">/* Update moon sprite attributes. */</span></a>
<a class="sourceLine" id="cb35-122" title="122">    moonEntry-&gt;x = (<span class="dt">int</span>)moonPos-&gt;x;</a>
<a class="sourceLine" id="cb35-123" title="123">    moonEntry-&gt;y = (<span class="dt">int</span>)moonPos-&gt;y;</a>
<a class="sourceLine" id="cb35-124" title="124"></a>
<a class="sourceLine" id="cb35-125" title="125">    <span class="co">/*</span></a>
<a class="sourceLine" id="cb35-126" title="126"><span class="co">     *  Update the OAM.</span></a>
<a class="sourceLine" id="cb35-127" title="127"><span class="co">     *</span></a>
<a class="sourceLine" id="cb35-128" title="128"><span class="co">     *  We have to copy our copy of OAM data into the actual OAM during</span></a>
<a class="sourceLine" id="cb35-129" title="129"><span class="co">     *  VBlank (writes to it are locked during other times).</span></a>
<a class="sourceLine" id="cb35-130" title="130"><span class="co">     */</span></a>
<a class="sourceLine" id="cb35-131" title="131">    swiWaitForVBlank();</a>
<a class="sourceLine" id="cb35-132" title="132">    updateOAM(oam);</a>
<a class="sourceLine" id="cb35-133" title="133">  }</a>
<a class="sourceLine" id="cb35-134" title="134"></a>
<a class="sourceLine" id="cb35-135" title="135">  <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb35-136" title="136">}</a>
<a class="sourceLine" id="cb35-137" title="137">      </a></code></pre></div>
<p>In summary, we simply set up our sound in the <code class="sourceCode cpp">main</code> function, and had the <code class="sourceCode cpp">handleInput</code> function play our sound whenever the up key is initially pressed.</p>
<h2>The all powerful maxmod</h2>
<p>We are barely touching what maxmod can do in this case study. maxmod can stop sounds after they've started playing, loop sounds, play music, and more without breaking a sweat (because the Nintendo DS doesn't have sweat glands anyway). I highly recommend you read about it on <a href="http://maxmod.org/">its homepage</a>, or at least run the maxmod demo (featured on said homepage) on a real Nintendo DS. You won't be disappointed.</p>
<h2>Compiling</h2>
<p>Check your includes.</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode C++"><code class="sourceCode cpp"><a class="sourceLine" id="cb36-1" title="1"><span class="pp">#include </span><span class="im">&lt;nds.h&gt;</span></a>
<a class="sourceLine" id="cb36-2" title="2"><span class="pp">#include </span><span class="im">&lt;maxmod9.h&gt;</span></a>
<a class="sourceLine" id="cb36-3" title="3"><span class="pp">#include </span><span class="im">&lt;assert.h&gt;</span></a>
<a class="sourceLine" id="cb36-4" title="4"><span class="pp">#include </span><span class="im">&quot;sprites.h&quot;</span></a>
<a class="sourceLine" id="cb36-5" title="5"><span class="pp">#include </span><span class="im">&quot;ship.h&quot;</span></a>
<a class="sourceLine" id="cb36-6" title="6"></a>
<a class="sourceLine" id="cb36-7" title="7"><span class="co">/* Backgrounds */</span></a>
<a class="sourceLine" id="cb36-8" title="8"><span class="pp">#include </span><span class="im">&quot;starField.h&quot;</span></a>
<a class="sourceLine" id="cb36-9" title="9"><span class="pp">#include </span><span class="im">&quot;planet.h&quot;</span></a>
<a class="sourceLine" id="cb36-10" title="10"><span class="pp">#include </span><span class="im">&quot;splash.h&quot;</span></a>
<a class="sourceLine" id="cb36-11" title="11"><span class="co">/* Sprites */</span></a>
<a class="sourceLine" id="cb36-12" title="12"><span class="pp">#include </span><span class="im">&quot;orangeShuttle.h&quot;</span></a>
<a class="sourceLine" id="cb36-13" title="13"><span class="pp">#include </span><span class="im">&quot;moon.h&quot;</span></a>
<a class="sourceLine" id="cb36-14" title="14"><span class="co">/* Sounds */</span></a>
<a class="sourceLine" id="cb36-15" title="15"><span class="pp">#include </span><span class="im">&quot;soundbank.h&quot;</span></a>
<a class="sourceLine" id="cb36-16" title="16"><span class="pp">#include </span><span class="im">&quot;soundbank_bin.h&quot;</span></a>
<a class="sourceLine" id="cb36-17" title="17">      </a></code></pre></div>
<p>This is the final iteration of the Orange Spaceship demo that we will cover in this edition of the manual. Compile it and enjoy the fruits of your labors. Mmm, tasty. You should hear a nice sound when you press the thrust button. The game output should now look like the screen shots in <a href="#chapter_9_screen_shot">figure_title</a>.</p>
<figure>
<img src="images/splash.png" alt="Flying around in the Orange Shuttle, with sound!" /><figcaption>Flying around in the Orange Shuttle, with sound!</figcaption>
</figure>
<figure>
<img src="images/starfield_with_moving_orange_shuttle.png" alt="Flying around in the Orange Shuttle, with sound!" /><figcaption>Flying around in the Orange Shuttle, with sound!</figcaption>
</figure>
<h1>Postface</h1>
<p>I hope you've enjoyed reading this manual as much as I've enjoyed writing it. I hope it has helped you to learn the basics of Nintendo DS programming, and if not, that it has pointed you in the correct direction. I wish you luck in all your future projects and endeavors.</p>
<p>Feel free to contact me <a href="mailto:jaeden@patater.com"></a>, if you need any help or have corrections or suggestions.</p>
<h1>Acknowledgements</h1>
<p>I'd like to offer special thanks to all those who have taught me these past few years about Nintendo DS programming. I apologize if I've left anyone off the list who has helped me. Special thanks to:</p>
<ul>
<li><p>John Haugeland</p></li>
<li><p>Martin Korth</p></li>
<li><p>Dave Murphy</p></li>
<li><p>Liran Nuna</p></li>
<li><p>Thorsten Lemke</p></li>
<li><p>Tobias Weyand</p></li>
<li><p>Shaun Taylor</p></li>
<li><p>Bryant Poffenberger</p></li>
<li><p>Hollis Jacobsen</p></li>
<li><p>Jeff Katz</p></li>
<li><p>James Zawacki</p></li>
<li><p>Michael Noland</p></li>
<li><p>Jasper Vijn</p></li>
<li><p>Jason Rogers</p></li>
<li><p>Christopher Double</p></li>
<li><p>Matt Luckett</p></li>
<li><p>Mathias Onisseit</p></li>
</ul>
<h1>Glossary</h1>
<p>Programming the Nintendo DS, and other embedded hardware systems in general, requires knowledge of many different concepts the terms used to describe them. Throughout this manual, we've introduced many terms that you probably have never encountered, excepting that you might have had other embedded hardware or video game programming practice.</p>
<dl>
<dt>Interrupt Request Handler</dt>
<dd><p>An interrupt handler is a function that is called after an interrupt is triggered. It is code designed to do something useful as a result of the interrupt. A common example of an interrupt handler is the VBlank interrupt handler. Upon entering VBlank, the Nintendo DS will cause the VBlank handler to run which will often update the graphics engines and/or VRAM to draw new images onto the display. The updating of the display is tied to the VBlank interrupt to avoid screen artifacts and to keep screen updating from the software side in sync with screen updatingon the hardware side.</p>
<p>See also .</p>
<p>See also .</p>
</dd>
<dt>Affine transformation matrix</dt>
<dd><p>Affine transformation matrix</p>
</dd>
<dt>Application programming interface</dt>
<dd><p>Application programming interface</p>
</dd>
<dt>Affine</dt>
<dd><p>Affine</p>
</dd>
<dt>Interrupt</dt>
<dd><p>Interrupt</p>
</dd>
<dt>Vertical blanking period</dt>
<dd><p>Vertical blanking period</p>
</dd>
</dl>
<h1>About the Author</h1>
<p>Jaeden Amero is currently doing new board bring up work for National Instruments in Austin, Texas, USA. He enjoys programming small computers, like the Nintendo DS and Game Boy Advance; tiny web servers; reconfigurable computing; unicycling; and playing the accordion in his free time.</p>
